# dashboard.py
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.colors import LinearSegmentedColormap
import streamlit.components.v1 as components
import scipy.stats as stats
from statsmodels.tsa.seasonal import seasonal_decompose
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Dashboard de An√°lises Agr√≠colas",
    page_icon="üå±",
    layout="wide",
    initial_sidebar_state="expanded",
)

# T√≠tulo principal
st.title("Dashboard de An√°lises Agr√≠colas")
st.markdown("---")

# Sidebar para navega√ß√£o
st.sidebar.title("Navega√ß√£o")
pagina = st.sidebar.radio(
    "Selecione uma an√°lise:",
    [
        "In√≠cio",
        "Mapas",
        "1. Tend√™ncias Temporais",
        "2. Comparativos Regionais",
        "3. Correla√ß√µes",
        "4. Volatilidade",
        "5. Taxonomia de Mesorregi√µes",
        "6. S√©ries Temporais",
        "7. Especializa√ß√£o Regional",
        "8. Resultados das An√°lises"
    ]
)

# Fun√ß√£o para carregar os dados
@st.cache_data
def carregar_dados():
    # Substitua pelo caminho correto do seu arquivo
    df = pd.read_parquet('dados_meteo.parquet')
    return df

df_consolidado = carregar_dados()
    
def ordenar_mesorregioes(mesorregioes):
    """
    Ordena mesorregi√µes: primeiro por UF (AL, AM, AP, etc) e depois pelo nome da regi√£o
    """
    return sorted(mesorregioes, 
                 key=lambda x: (x.split(' - ')[-1] if ' - ' in x else 'ZZ',  # Sort by state code
                                x.split(' - ')[0] if ' - ' in x else x))      # Then by region name

mesorregioes = df_consolidado['Mesorregi√£o'].unique()
mesorregioes_ordenadas = ordenar_mesorregioes(mesorregioes)    

# Configurar padr√µes
if 'produto_correlacao' not in st.session_state:
    # Default to the first product in the dataset
    produtos_disponiveis = sorted(df_consolidado['Produto'].unique())
    if produtos_disponiveis:
        st.session_state.produto_correlacao = produtos_disponiveis[0]
    else:
        st.session_state.produto_correlacao = None

if 'modo_visualizacao' not in st.session_state:
    st.session_state.modo_visualizacao = "Ano √önico"

if 'ano_selecionado' not in st.session_state:
    anos_disponiveis = sorted([int(ano) for ano in df_consolidado['Ano'].unique()])
    if anos_disponiveis:
        # Set default to 2022 or the latest year
        ano_padrao = 2022 if 2022 in anos_disponiveis else anos_disponiveis[-1]
        st.session_state.ano_selecionado = ano_padrao
    else:
        st.session_state.ano_selecionado = None

if 'periodo_selecionado' not in st.session_state:
    st.session_state.periodo_selecionado = []

# Filtros para p√°gina 3
if pagina == "3. Correla√ß√µes":
    st.sidebar.markdown("""
    <div style="border:3px solid #000000; border-radius:1px; padding:1px; margin:20px ;">
<center><h4 style="color:#00000; margin-top:1">Controles de Correla√ß√£o</h4></center>

    """, unsafe_allow_html=True)
    
    # Sele√ß√£o de produto - use df_consolidado here, not df_filtrado
    produto_correlacao = st.sidebar.selectbox(
        "Selecione um produto",
        sorted(df_consolidado['Produto'].unique()),
        index=list(sorted(df_consolidado['Produto'].unique())).index(st.session_state.produto_correlacao) 
            if st.session_state.produto_correlacao in sorted(df_consolidado['Produto'].unique()) else 0,
        key="produto_correlacao_select"
    )
    st.session_state.produto_correlacao = produto_correlacao
    
    # Modo de visualiza√ß√£o
    modo_visualizacao = st.sidebar.radio(
        "Modo de visualiza√ß√£o:",
        ["Ano √önico", "Agregado 4 Anos", "Todos os Anos"],
        index=["Ano √önico", "Agregado 4 Anos", "Todos os Anos"].index(st.session_state.modo_visualizacao)
            if st.session_state.modo_visualizacao in ["Ano √önico", "Agregado 4 Anos", "Todos os Anos"] else 0,
        key="modo_visualizacao_radio"
    )
    st.session_state.modo_visualizacao = modo_visualizacao
    
    if modo_visualizacao == "Ano √önico":
        # Get the data for the selected product
        dados_produto = df_consolidado[df_consolidado['Produto'] == produto_correlacao]
        
        # Create a list of available years as Python integers (not NumPy integers)
        anos_disponiveis = sorted([int(ano) for ano in dados_produto['Ano'].unique()])
        
        # Set default year (2022 if available, otherwise the most recent year)
        ano_padrao = 2022 if 2022 in anos_disponiveis else anos_disponiveis[-1]
        
        # Find the index of the current year or default year
        try:
            atual_ano = st.session_state.ano_selecionado if st.session_state.ano_selecionado in anos_disponiveis else ano_padrao
            indice_ano = anos_disponiveis.index(atual_ano)
        except ValueError:
            indice_ano = 0
        
        # Create the year selection dropdown
        ano_selecionado = st.sidebar.selectbox(
            "Selecione o ano:",
            anos_disponiveis,
            index=indice_ano,
            key="ano_selecionado_select" 
        )
        st.session_state.ano_selecionado = ano_selecionado
        
    elif modo_visualizacao == "Agregado 4 Anos":
        dados_produto = df_consolidado[df_consolidado['Produto'] == produto_correlacao]

        if not dados_produto.empty:
            # Ensure Ano is integer type
            dados_produto['Ano'] = dados_produto['Ano'].astype(int)
            min_ano = dados_produto['Ano'].min()
            max_ano = dados_produto['Ano'].max()

            periodos = []
            if min_ano <= max_ano:
                # Handle the first special 5-year period (e.g., 1990-1994)
                fim_primeiro_periodo = min(min_ano + 4, max_ano)
                periodos.append(f"{min_ano}-{fim_primeiro_periodo}")

                # Start the next period after the first one
                inicio = fim_primeiro_periodo + 1

                # Loop for subsequent standard 4-year periods
                while inicio <= max_ano:
                    fim = min(inicio + 3, max_ano) # 4-year duration (inicio, +1, +2, +3)
                    periodos.append(f"{inicio}-{fim}")
                    inicio = fim + 1

            if periodos:
                # Find current period or default to the most recent
                atual_periodo = st.session_state.periodo_selecionado if st.session_state.periodo_selecionado in periodos else periodos[-1]
                try:
                    indice_periodo = periodos.index(atual_periodo)
                except ValueError:
                    indice_periodo = len(periodos) - 1
                
                periodo_selecionado = st.sidebar.selectbox(
                    "Selecione o per√≠odo",
                    periodos,
                    index=indice_periodo,
                    key="periodo_selecionado_select"
                )
                st.session_state.periodo_selecionado = periodo_selecionado

    # Filtro de mesorregi√µes com busca
    mesorregiao_selecionada = st.sidebar.multiselect(
        "Mesorregi√µes:",
        mesorregioes_ordenadas,
        default=[]
    )

    # Primeiro filtre pelo produto
    df_filtrado = df_consolidado[df_consolidado['Produto'] == produto_correlacao]

    # Depois aplique os filtros de ano/per√≠odo
    if modo_visualizacao == "Ano √önico" and ano_selecionado is not None:
        df_filtrado = df_filtrado[df_filtrado['Ano'] == ano_selecionado]
    elif modo_visualizacao == "Agregado 4 Anos" and periodo_selecionado:
        anos_periodo = periodo_selecionado.split('-')
        if len(anos_periodo) == 2:
            ano_inicio = int(anos_periodo[0])
            ano_fim = int(anos_periodo[1])
            df_filtrado = df_filtrado[(df_filtrado['Ano'] >= ano_inicio) & (df_filtrado['Ano'] <= ano_fim)]
    elif modo_visualizacao == "Todos os Anos":
        # N√£o aplica filtro de ano, mant√©m todos os anos para o produto selecionado
        pass
    
    # Por √∫ltimo, aplique o filtro de mesorregi√£o AP√ìS outros filtros
    if mesorregiao_selecionada:
        df_filtrado = df_filtrado[df_filtrado['Mesorregi√£o'].isin(mesorregiao_selecionada)]

    # Debug para verificar n√∫mero de registros ap√≥s cada filtro
    st.sidebar.text(f"Registros: {len(df_filtrado)}")
    
    st.sidebar.markdown("</div>", unsafe_allow_html=True)
# Filtros para p√°gina 4
elif pagina == "4. Volatilidade":
    st.sidebar.markdown("""
    <div style="border:3px solid #000000; border-radius:1px; padding:1px; margin:20px ;">
    <center><h4 style="color:#00000; margin-top:1">Produto para an√°lise de volatilidade regional</h4></center>
    """, unsafe_allow_html=True)
   
    produto_volatilidade = st.sidebar.selectbox(
        "Produtos:",
        sorted(df_consolidado['Produto'].unique()),
        key="produto_volatilidade"
    )
    # Filtro de mesorregi√µes com busca
    regioes_destacadas = st.sidebar.multiselect(
            "Mesorregi√µes:",
            mesorregioes_ordenadas,
            key='regioes_destacadas_volatilidade',
            default=[]
        )    
    df_filtrado = df_consolidado.copy()# Filtros globais
# Filtros para todas outras paginas
else:
    with st.sidebar.expander("Filtros de Produto e Regi√£o", expanded=False):
        # Filtro de per√≠odo (mais compacto)
        anos = sorted(df_consolidado['Ano'].unique())
        periodo = st.sidebar.slider(
            "Selecione o per√≠odo:",
            min_value=min(anos),
            max_value=max(anos),
            value=(min(anos), max(anos))
        )
        
        # Filtro de produtos com busca
        produtos = sorted(df_consolidado['Produto'].unique())
        produto_selecionado = st.multiselect(
            "Produtos:",
            produtos,
            default=[]
        )
        
        # Filtro de mesorregi√µes com busca
        mesorregiao_selecionada = st.multiselect(
            "Mesorregi√µes:",
            mesorregioes_ordenadas,
            default=[]
        )
    if produto_selecionado:
        df_filtrado = df_consolidado[df_consolidado['Produto'].isin(produto_selecionado)]
    else:
        df_filtrado = df_consolidado.copy()

    if mesorregiao_selecionada:
        df_filtrado = df_filtrado[df_filtrado['Mesorregi√£o'].isin(mesorregiao_selecionada)]

    df_filtrado = df_filtrado[(df_filtrado['Ano'] >= periodo[0]) & (df_filtrado['Ano'] <= periodo[1])]

main_container = st.container()
with main_container:
    # P√°gina inicial
    if pagina == "In√≠cio":
        st.header("Vis√£o Geral")
        
        st.subheader("Contexto")
        st.markdown("""
            Este dashboard √© uma an√°lise de dados agr√≠colas brasileiros a n√≠vel de mesorregi√£o. Inclui dados de produtividade, produ√ß√£o e √°rea plantada as maiores culturas do pa√≠s ao longo do per√≠odo de 1990 a 2022, com dados meteorol√≥gicos de 2000 a 2022.

            Utilize o menu na barra lateral para navegar entre as diferentes an√°lises dispon√≠veis.

            Os filtros globais na barra lateral permitem personalizar a visualiza√ß√£o dos dados por produto, mesorregi√£o e per√≠odo de tempo.
            
            ---
            """)
        
        st.subheader("Potenciais clientes e an√°lises")
        col1, col2 = st.columns(2)
        with col1:
            with st.expander("Produtores Rurais e Cooperativas Agr√≠colas", expanded=False):
                st.markdown('''
- Tend√™ncias temporais de rendimento por cultura e regi√£o
- Pontos de inflex√£o na produtividade (para identificar quando houve saltos tecnol√≥gicos)
- Correla√ß√µes entre √°rea plantada e rendimento (economias de escala)
- Volatilidade regional (identificar regi√µes mais est√°veis para reduzir riscos)
- Impacto de vari√°veis clim√°ticas no rendimento
            ''')

            with st.expander("Institui√ß√µes Financeiras e Seguradoras", expanded=False):
                st.markdown('''
- Volatilidade da produ√ß√£o por cultura e regi√£o (para precifica√ß√£o de seguros)
- Diversifica√ß√£o agr√≠cola por regi√£o (para an√°lise de risco de carteira)
- Correla√ß√µes com vari√°veis clim√°ticas (para modelagem de risco)
- Detec√ß√£o de outliers e eventos extremos nas s√©ries temporais
- Especializa√ß√£o regional (para estrat√©gias de cr√©dito direcionado)
''')
            with st.expander("√ìrg√£os Governamentais", expanded=False):
                st.markdown('''
- Tend√™ncias de longo prazo na produtividade
- Diversifica√ß√£o agr√≠cola por regi√£o (para seguran√ßa alimentar)
- Taxonomia de mesorregi√µes (para pol√≠ticas regionalizadas)
- √çndice de especializa√ß√£o regional (para desenvolvimento econ√¥mico local)
- Impacto de vari√°veis clim√°ticas (para pol√≠ticas de adapta√ß√£o clim√°tica)
''')
        with col2:
            with st.expander("Empresas de Tecnologia Agr√≠cola", expanded=False):
                st.markdown('''
- Pontos de inflex√£o na produtividade (para identificar impacto de inova√ß√µes)
- Correla√ß√µes entre vari√°veis clim√°ticas e rendimento (para desenvolver solu√ß√µes adaptativas)
- Regi√µes com baixa produtividade e alta volatilidade (oportunidades de mercado)
- An√°lise de clusters de mesorregi√µes (para personaliza√ß√£o de solu√ß√µes)
- Comparativos regionais de rendimento (benchmarking para tecnologias)
''')

            with st.expander("Ind√∫strias de Processamento Agr√≠cola", expanded=False):
                st.markdown('''
- Mapeamento de mesorregi√µes especializadas (para localiza√ß√£o de plantas)
- Tend√™ncias de produ√ß√£o e volatilidade (para planejamento de suprimentos)
- Sazonalidade na produ√ß√£o (para gest√£o de estoques)
- Distribui√ß√£o geogr√°fica da produ√ß√£o (para otimiza√ß√£o log√≠stica)
- Proje√ß√µes de s√©ries temporais (para planejamento estrat√©gico)
''')
            with st.expander("Investidores em Terras Agr√≠colas", expanded=False):
                st.markdown('''                
- Tend√™ncias de longo prazo na produtividade por regi√£o
- Volatilidade regional (para avalia√ß√£o de risco)
- Especializa√ß√£o regional (para identifica√ß√£o de oportunidades)
- Correla√ß√µes com vari√°veis clim√°ticas (para avalia√ß√£o de resili√™ncia)
- Comparativos de rendimento entre regi√µes (para valora√ß√£o de terras)
''')
        st.markdown('---')
        col1, col2 = st.columns(2)
        
        with col1:            
            st.subheader("Resumo dos Dados")
            
            # Estat√≠sticas b√°sicas
            num_mesorregioes = df_filtrado['Mesorregi√£o'].nunique()
            num_produtos = df_filtrado['Produto'].nunique()
            periodo_analise = f"{df_filtrado['Ano'].min()} a {df_filtrado['Ano'].max()}"
            
            st.markdown(f"**N√∫mero de Mesorregi√µes:** {num_mesorregioes}")
            st.markdown(f"**N√∫mero de Produtos:** {num_produtos}")
            st.markdown(f"**Per√≠odo de An√°lise:** {periodo_analise}")
        
        with col2:
            st.subheader("Distribui√ß√£o da Produ√ß√£o por Produto")
            
            # Agrupar por produto para visualiza√ß√£o
            producao_por_produto = df_filtrado.groupby('Produto')['Producao_Toneladas'].sum().reset_index()
            producao_por_produto = producao_por_produto.sort_values('Producao_Toneladas', ascending=False)
            
            fig = px.pie(
                producao_por_produto,
                values='Producao_Toneladas',
                names='Produto',
                title='Distribui√ß√£o da Produ√ß√£o Total por Produto',
                template='plotly_white',
                hole=0.3
            )
            st.plotly_chart(fig, use_container_width=True)

    # Mapas do PowerBI
    elif pagina == "Mapas":
        powerbi_url = "https://app.powerbi.com/view?r=eyJrIjoiMWRhOWY4NzItYzMwNi00Yzk0LWIxZmYtNTMyYzlhZDUzM2U4IiwidCI6ImMxNzdmNmRkLWY1MTUtNDRlNy05ZmMzLTZiNzZjODdhZmViMCJ9&pageName=e52d3bda5d537e68a452"

        # Embed in an iframe
        components.iframe(powerbi_url, height=600, width=600)
    
    # 1. Tend√™ncias Temporais    
    elif pagina == "1. Tend√™ncias Temporais":
        st.header("An√°lise de Tend√™ncias Temporais")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o apresenta a evolu√ß√£o do rendimento m√©dio de cada cultura ao longo do tempo
        e identifica pontos de inflex√£o (anos com mudan√ßas significativas).
        """)
        
        # Visualiza√ß√£o interativa com Plotly
        st.subheader("Evolu√ß√£o do Rendimento M√©dio por Cultura")
        
        # Agrupar por Produto e Ano para calcular o rendimento m√©dio
        rendimento_medio = df_filtrado.groupby(['Produto', 'Ano'])['Rendimento_KgPorHectare'].mean().reset_index()
        
        # Criar gr√°fico interativo
        fig = px.line(
            rendimento_medio,
            x='Ano',
            y='Rendimento_KgPorHectare',
            color='Produto',
            markers=True,
            title='Evolu√ß√£o do Rendimento M√©dio por Cultura (1990-2022)',
            labels={'Rendimento_KgPorHectare': 'Rendimento (Kg/Hectare)', 'Ano': 'Ano'},
            template='plotly_white'
        )
        
        # Adicionar linha de tend√™ncia usando regress√£o linear
        for produto in rendimento_medio['Produto'].unique():
            df_produto = rendimento_medio[rendimento_medio['Produto'] == produto]
            X = df_produto['Ano']
            y = df_produto['Rendimento_KgPorHectare']
            
            # Ajustar modelo de regress√£o linear
            coef = np.polyfit(X, y, 1)
            linha_tendencia = np.poly1d(coef)
            
            # Adicionar linha de tend√™ncia ao gr√°fico
            fig.add_scatter(
                x=X,
                y=linha_tendencia(X),
                mode='lines',
                line=dict(dash='dash'),
                name=f'Tend√™ncia - {produto}',
                opacity=0.7
            )
        
        # Melhorar o layout
        fig.update_layout(
            height=600,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=-0.3,
                xanchor="center",
                x=0.5
            ),
            hovermode='x unified'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Identifica√ß√£o de pontos de inflex√£o
        st.subheader("Pontos de Inflex√£o por Cultura")
        
        # Criar duas colunas para os controles, com propor√ß√£o que deixa mais espa√ßo para o gr√°fico
        col1, col2 = st.columns([1, 4])

        with col1:
            # Escolher um produto espec√≠fico para an√°lise detalhada (coluna menor)
            produto_inflexao = st.selectbox(
                "Cultura:",
                sorted(df_filtrado['Produto'].unique()),
                key="produto_inflexao"
            )
            
            # Definir limiar de varia√ß√£o (na mesma coluna menor)
            limiar = st.slider(
                "Limiar de varia√ß√£o (%):",
                min_value=5,
                max_value=50,
                value=15,
                step=5,
                key="limiar_variacao"
            )
            
        with col2:
            # Filtrar dados do produto selecionado
            dados_produto = rendimento_medio[rendimento_medio['Produto'] == produto_inflexao].sort_values('Ano')
            
            # Calcular a taxa de varia√ß√£o anual
            dados_produto['Variacao'] = dados_produto['Rendimento_KgPorHectare'].pct_change() * 100
            
            with st.expander("‚ÑπÔ∏è O que significa este limiar?"):
                st.markdown("""
                O limiar de varia√ß√£o (15% por padr√£o) determina o que √© considerado um ponto de inflex√£o significativo na produtividade de uma cultura. Pontos acima desse limiar representam mudan√ßas importantes que podem ser causadas por:
                
                - Inova√ß√µes tecnol√≥gicas (novas variedades, t√©cnicas de manejo)
                - Eventos clim√°ticos extremos (secas, inunda√ß√µes) 
                - Pol√≠ticas agr√≠colas (subs√≠dios, programas de apoio)
                - Mudan√ßas no mercado (pre√ßos, demanda)
                """)
                
            # Identificar pontos de inflex√£o
            pontos_inflexao = dados_produto[abs(dados_produto['Variacao']) > limiar]
            
            # Criar gr√°fico com pontos de inflex√£o
            fig = go.Figure()
            
            # Adicionar s√©rie principal
            fig.add_trace(go.Scatter(
                x=dados_produto['Ano'],
                y=dados_produto['Rendimento_KgPorHectare'],
                mode='lines+markers',
                name=produto_inflexao,
                line=dict(width=2)
            ))
            
            # Adicionar pontos de inflex√£o
            if not pontos_inflexao.empty:
                fig.add_trace(go.Scatter(
                    x=pontos_inflexao['Ano'],
                    y=pontos_inflexao['Rendimento_KgPorHectare'],
                    mode='markers',
                    marker=dict(size=12, color='red', symbol='star'),
                    name='Pontos de Inflex√£o',
                    text=[f"Varia√ß√£o: {var:.1f}%" for var in pontos_inflexao['Variacao']],
                    hovertemplate='Ano: %{x}<br>Rendimento: %{y} Kg/Ha<br>%{text}'
                ))
            
            # Configurar layout
            fig.update_layout(
                title=f'Evolu√ß√£o do Rendimento de {produto_inflexao} com Pontos de Inflex√£o (Varia√ß√£o > {limiar}%)',
                xaxis_title='Ano',
                yaxis_title='Rendimento (Kg/Hectare)',
                height=500,
                template='plotly_white',
                hovermode='closest'
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
        # Tabela de pontos de inflex√£o
        if not pontos_inflexao.empty:
            st.write(f"**Pontos de inflex√£o identificados para {produto_inflexao}** (Varia√ß√£o > {limiar}%):")
            st.dataframe(
                pontos_inflexao[['Ano', 'Rendimento_KgPorHectare', 'Variacao']].rename(
                    columns={'Variacao': 'Varia√ß√£o (%)'}
                ).set_index('Ano').style.format({
                    'Rendimento_KgPorHectare': '{:.2f}',
                    'Varia√ß√£o (%)': '{:.2f}%'
                })
            )
        else:
            st.info(f"N√£o foram identificados pontos de inflex√£o para {produto_inflexao} com o limiar de {limiar}%.")

    # 2. Comparativos Regionais
    elif pagina == "2. Comparativos Regionais":
        st.header("Comparativos Regionais")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o apresenta o ranking das mesorregi√µes mais produtivas para cada cultura
        e mapas de calor mostrando a distribui√ß√£o espacial da produtividade.
        """)
        
        # Ranking das mesorregi√µes mais produtivas
        st.subheader("Ranking das Mesorregi√µes mais Produtivas")
        
        # Selecionar o produto para o ranking
        produto_ranking = st.selectbox(
            "Selecione um produto:",
            sorted(df_filtrado['Produto'].unique()),
            key="produto_ranking"
        )
        
        # Agrupar por Mesorregi√£o para o produto selecionado
        dados_ranking = df_filtrado[df_filtrado['Produto'] == produto_ranking]
        ranking = dados_ranking.groupby('Mesorregi√£o')['Rendimento_KgPorHectare'].mean().reset_index()
        ranking = ranking.sort_values('Rendimento_KgPorHectare', ascending=False).reset_index(drop=True)
        
        # Definir o n√∫mero de mesorregi√µes a mostrar
        num_mesorregioes = st.slider(
            "N√∫mero de mesorregi√µes no ranking:",
            min_value=5,
            max_value=min(30, len(ranking)),
            value=10
        )
        
        # Criar gr√°fico de barras
        fig = px.bar(
            ranking.head(num_mesorregioes),
            y='Mesorregi√£o',
            x='Rendimento_KgPorHectare',
            orientation='h',
            title=f'Top {num_mesorregioes} Mesorregi√µes mais Produtivas - {produto_ranking}',
            labels={'Rendimento_KgPorHectare': 'Rendimento M√©dio (Kg/Hectare)', 'Mesorregi√£o': ''},
            template='plotly_white',
            color='Rendimento_KgPorHectare',
            color_continuous_scale=px.colors.sequential.Viridis
        )
        
        fig.update_layout(height=600, yaxis={'categoryorder': 'total ascending'})
        st.plotly_chart(fig, use_container_width=True)
        
        # Tabela com o ranking completo
        with st.expander("Ver tabela com o ranking completo"):
            st.dataframe(
                ranking.style.format({'Rendimento_KgPorHectare': '{:.2f}'})
                .background_gradient(cmap='viridis', subset=['Rendimento_KgPorHectare'])
            )
        
        # Mapa de calor da produ√ß√£o por regi√£o e produto
        st.markdown('---')
        st.header('Mapas de Calor')
        st.markdown("""
        - As cores mais intensas (amarelo) indicam valores mais altos (maior produtividade/produ√ß√£o)
        - Os dados est√£o normalizados por coluna (produto) - valor 1 representa a regi√£o com maior valor
        - Escala logar√≠tmica √© usada para melhorar a visualiza√ß√£o das diferen√ßas entre regi√µes
        - Regi√µes ordenadas de norte a sul
        """)
        
        # Extrair o estado de cada mesorregi√£o
        def extrair_estado(mesorregiao):
            partes = mesorregiao.split(' - ')
            if len(partes) > 1:
                return partes[1]
            return ''

        # Definir ordem das regi√µes brasileiras e estados
        regioes_brasil = {
            'Norte': ['AC', 'AM', 'AP', 'PA', 'RO', 'RR', 'TO'],
            'Nordeste': ['AL', 'BA', 'CE', 'MA', 'PB', 'PE', 'PI', 'RN', 'SE'],
            'Centro-Oeste': ['DF', 'GO', 'MS', 'MT'],
            'Sudeste': ['ES', 'MG', 'RJ', 'SP'],
            'Sul': ['PR', 'RS', 'SC']
        }

        # Criar uma fun√ß√£o para ordenar as mesorregi√µes
        def ordenar_mesorregioes_norte_sul(mesorregioes):
            # Criar um dicion√°rio para mapear estados para suas regi√µes
            estado_para_regiao = {}
            for regiao, estados in regioes_brasil.items():
                for estado in estados:
                    estado_para_regiao[estado] = regiao
            
            # Criar uma lista de tuplas (regi√£o, estado, mesorregi√£o)
            dados_ordenacao = []
            for mesorregiao in mesorregioes:
                estado = extrair_estado(mesorregiao)
                regiao = estado_para_regiao.get(estado, 'Outra')
                dados_ordenacao.append((regiao, estado, mesorregiao))
            
            # Ordenar primeira por regi√£o (seguindo a ordem: Norte, Nordeste, Centro-Oeste, Sudeste, Sul)
            ordem_regioes = ['Norte', 'Nordeste', 'Centro-Oeste', 'Sudeste', 'Sul', 'Outra']
            dados_ordenacao.sort(key=lambda x: (ordem_regioes.index(x[0]), x[1], x[2]))
            
            # Retornar apenas a lista de mesorregi√µes ordenadas
            return [item[2] for item in dados_ordenacao]

        # Mapa de Calor da Produ√ß√£o
        st.subheader(f"Mapa de Calor da Produ√ß√£o ({periodo[0]}-{periodo[1]})")
        
        producao_pivot = df_filtrado.pivot_table(
            values='Producao_Toneladas',
            index='Mesorregi√£o',
            columns='Produto',
            aggfunc='sum'
        ).fillna(0)
        
        # Ordenar mesorregi√µes
        mesorregioes_ordenadas = ordenar_mesorregioes_norte_sul(producao_pivot.index.tolist())

        # Reordenar o pivot table
        producao_pivot = producao_pivot.reindex(mesorregioes_ordenadas)

        # Normalizar usando escala logar√≠tmica
        producao_normalizada = producao_pivot.copy()
        for col in producao_normalizada.columns:
            if producao_normalizada[col].max() != 0:
                # Add small value to avoid log(0)
                normalized_values = producao_normalizada[col] / producao_normalizada[col].max()
                # Apply log transformation (adding 0.01 to avoid log(0))
                producao_normalizada[col] = np.log10(normalized_values + 0.01) / np.log10(1.01)
                # Rescale to 0-1 range
                if producao_normalizada[col].max() != producao_normalizada[col].min():
                    producao_normalizada[col] = (producao_normalizada[col] - producao_normalizada[col].min()) / (producao_normalizada[col].max() - producao_normalizada[col].min())

        # Create custom hover text with better formatting
        hover_text = []
        for i, mesorregiao in enumerate(producao_normalizada.index):
            row_hover = []
            for j, produto in enumerate(producao_normalizada.columns):
                # Get original and normalized values
                orig_value = producao_pivot.iloc[i, j]
                norm_value = producao_pivot.iloc[i, j] / producao_pivot[producao_pivot.columns[j]].max()
                row_hover.append(f"Regi√£o: {mesorregiao}<br>Produto: {produto}<br>Produ√ß√£o: {orig_value:.2f} ton<br>Valor Normalizado: {norm_value:.4f}")
            hover_text.append(row_hover)

        fig = px.imshow(
            producao_normalizada,
            labels=dict(x="Produto", y="Mesorregi√£o", color="Produ√ß√£o Normalizada (Log)"),
            x=producao_normalizada.columns,
            y=producao_normalizada.index,
            aspect="auto",
            color_continuous_scale='Viridis'
        )

        # Use the custom hover text
        fig.update_traces(hovertemplate="%{customdata}", customdata=hover_text)
        fig.update_layout(height=600)
        st.plotly_chart(fig, use_container_width=True)
        
        # Mapa de calor do rendimento
        st.subheader(f"Mapa de Calor do Rendimento ({periodo[0]}-{periodo[1]})")
        
        # Op√ß√µes para o mapa de calor
        mapa_opcao = st.radio(
            "Selecione o tipo de visualiza√ß√£o:",
            ["Por Produto (todas as mesorregi√µes)", "Por Mesorregi√£o (todos os produtos)"]
        )
        
        if mapa_opcao == "Por Produto (todas as mesorregi√µes)":
            # Agrupar por Mesorregi√£o e Produto
            mapa_dados = df_filtrado.groupby(['Mesorregi√£o', 'Produto'])['Rendimento_KgPorHectare'].mean().reset_index()
            
            # Criar tabela pivotada
            mapa_pivot = mapa_dados.pivot_table(
                values='Rendimento_KgPorHectare',
                index='Mesorregi√£o',
                columns='Produto'
            ).fillna(0)

            # Ordenar mesorregi√µes
            mesorregioes_ordenadas = ordenar_mesorregioes_norte_sul(mapa_pivot.index.tolist())

            # Reordenar o pivot table
            mapa_pivot = mapa_pivot.reindex(mesorregioes_ordenadas)
            
            # Normalizar usando escala logar√≠tmica
            mapa_normalizado = mapa_pivot.copy()
            for col in mapa_normalizado.columns:
                if mapa_normalizado[col].max() != 0:
                    # Add small value to avoid log(0)
                    normalized_values = mapa_normalizado[col] / mapa_normalizado[col].max()
                    # Apply log transformation (adding 0.01 to avoid log(0))
                    mapa_normalizado[col] = np.log10(normalized_values + 0.01) / np.log10(1.01)
                    # Rescale to 0-1 range
                    if mapa_normalizado[col].max() != mapa_normalizado[col].min():
                        mapa_normalizado[col] = (mapa_normalizado[col] - mapa_normalizado[col].min()) / (mapa_normalizado[col].max() - mapa_normalizado[col].min())
            
            # Create custom hover text with better formatting
            hover_text = []
            for i, mesorregiao in enumerate(mapa_normalizado.index):
                row_hover = []
                for j, produto in enumerate(mapa_normalizado.columns):
                    # Get original and normalized values
                    orig_value = mapa_pivot.iloc[i, j]
                    norm_value = mapa_pivot.iloc[i, j] / mapa_pivot[mapa_pivot.columns[j]].max()
                    row_hover.append(f"Regi√£o: {mesorregiao}<br>Produto: {produto}<br>Rendimento: {orig_value:.2f} kg/ha<br>Valor Normalizado: {norm_value:.4f}")
                hover_text.append(row_hover)
            
            # Criar mapa de calor
            fig = px.imshow(
                mapa_normalizado,
                labels=dict(x="Produto", y="Mesorregi√£o", color="Rendimento Normalizado (Log)"),
                x=mapa_normalizado.columns,
                y=mapa_normalizado.index,
                aspect="auto",
                color_continuous_scale='Viridis'
            )
            
            # Use the custom hover text
            fig.update_traces(hovertemplate="%{customdata}", customdata=hover_text)
            
            fig.update_layout(height=800, title="Distribui√ß√£o Espacial da Produtividade por Produto (Normalizada)")
            st.plotly_chart(fig, use_container_width=True)
        else:
            # Selecionar mesorregi√£o para an√°lise
            mesorregiao_mapa = st.selectbox(
                "Selecione uma mesorregi√£o:",
                sorted(df_filtrado['Mesorregi√£o'].unique()),
                key="mesorregiao_mapa"
            )
            
            # Agrupar por Ano e Produto para a mesorregi√£o selecionada
            mapa_dados = df_filtrado[df_filtrado['Mesorregi√£o'] == mesorregiao_mapa]
            mapa_dados = mapa_dados.groupby(['Ano', 'Produto'])['Rendimento_KgPorHectare'].mean().reset_index()
            
            # Criar tabela pivotada
            mapa_pivot = mapa_dados.pivot_table(
                values='Rendimento_KgPorHectare',
                index='Ano',
                columns='Produto'
            ).fillna(0)
            
            # Informa√ß√µes sobre como interpretar o mapa de calor
            st.markdown("""
            **Como interpretar este Mapa de Calor:**
            - As cores mais intensas (amarelo) indicam valores mais altos de rendimento
            - Os dados est√£o normalizados por coluna (produto) - valor 1 representa o ano com maior rendimento daquele produto
            - Escala logar√≠tmica √© usada para melhorar a visualiza√ß√£o das diferen√ßas entre anos
            - Anos ordenados cronologicamente do mais antigo ao mais recente
            """)
            
            # Garantir que os anos estejam em ordem cronol√≥gica
            mapa_pivot = mapa_pivot.sort_index()
            
            # Normalizar usando escala logar√≠tmica
            mapa_normalizado = mapa_pivot.copy()
            for col in mapa_normalizado.columns:
                if mapa_normalizado[col].max() != 0:
                    # Add small value to avoid log(0)
                    normalized_values = mapa_normalizado[col] / mapa_normalizado[col].max()
                    # Apply log transformation (adding 0.01 to avoid log(0))
                    mapa_normalizado[col] = np.log10(normalized_values + 0.01) / np.log10(1.01)
                    # Rescale to 0-1 range
                    if mapa_normalizado[col].max() != mapa_normalizado[col].min():
                        mapa_normalizado[col] = (mapa_normalizado[col] - mapa_normalizado[col].min()) / (mapa_normalizado[col].max() - mapa_normalizado[col].min())
            
            # Create custom hover text with better formatting
            hover_text = []
            for i, ano in enumerate(mapa_normalizado.index):
                row_hover = []
                for j, produto in enumerate(mapa_normalizado.columns):
                    # Get original and normalized values
                    orig_value = mapa_pivot.iloc[i, j]
                    norm_value = mapa_pivot.iloc[i, j] / mapa_pivot[mapa_pivot.columns[j]].max()
                    row_hover.append(f"Ano: {ano}<br>Produto: {produto}<br>Rendimento: {orig_value:.2f} kg/ha<br>Valor Normalizado: {norm_value:.4f}")
                hover_text.append(row_hover)
            
            # Criar mapa de calor
            fig = px.imshow(
                mapa_normalizado,
                labels=dict(x="Produto", y="Ano", color="Rendimento Normalizado (Log)"),
                x=mapa_normalizado.columns,
                y=mapa_normalizado.index,
                aspect="auto",
                color_continuous_scale='Viridis'
            )
            
            # Use the custom hover text
            fig.update_traces(hovertemplate="%{customdata}", customdata=hover_text)
            
            fig.update_layout(
                height=800, 
                title=f"Evolu√ß√£o da Produtividade por Produto em {mesorregiao_mapa} ({periodo[0]}-{periodo[1]})",
                yaxis={'dtick': 5}  # Show year labels with interval of 5
            )
            st.plotly_chart(fig, use_container_width=True)  

    # 3. Correla√ß√µes entre vari√°veis
    elif pagina == "3. Correla√ß√µes":
        st.header("Correla√ß√µes entre Vari√°veis")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o analisa as rela√ß√µes entre diferentes vari√°veis, como √°rea plantada e rendimento 
        (para verificar se h√° economias de escala) e a correla√ß√£o entre valor da produ√ß√£o e rendimento.
        Tamb√©m inclui an√°lises de correla√ß√£o com vari√°veis clim√°ticas.
        """)
        
        # Main content area - using the controls from the sidebar
        # Get values from session state
        produto_correlacao = st.session_state.produto_correlacao
        modo_visualizacao = st.session_state.modo_visualizacao
        
        # For correlation page only filter by product, not by the global filters
        dados_produto = df_filtrado
        if dados_produto.empty:
            st.warning(f"N√£o h√° dados dispon√≠veis para {produto_correlacao}.")
            st.stop()
        
        # Processar dados com base no modo de visualiza√ß√£o
        if modo_visualizacao == "Ano √önico":
            ano_selecionado = st.session_state.ano_selecionado
            dados_produto = dados_produto[dados_produto['Ano'] == ano_selecionado]
            
            if dados_produto.empty:
                st.warning(f"N√£o h√° dados dispon√≠veis para {produto_correlacao} no ano {ano_selecionado}.")
                st.stop()
            
            titulo_area_rend = f'{produto_correlacao} ({ano_selecionado})'
            titulo_valor_rend = f'{produto_correlacao} ({ano_selecionado})'
            
        elif modo_visualizacao == "Agregado 4 Anos":
            periodo_selecionado = st.session_state.periodo_selecionado
            try:
                inicio_periodo, fim_periodo = map(int, periodo_selecionado.split('-'))
                
                dados_produto = dados_produto[(dados_produto['Ano'] >= inicio_periodo) & (dados_produto['Ano'] <= fim_periodo)]
                
                if dados_produto.empty:
                    st.warning(f"N√£o h√° dados dispon√≠veis para {produto_correlacao} no per√≠odo {periodo_selecionado}.")
                    st.stop()
                
                titulo_area_rend = f'{produto_correlacao} ({periodo_selecionado})'
                titulo_valor_rend = f'{produto_correlacao} ({periodo_selecionado})'
            except:
                st.error(f"Formato de per√≠odo inv√°lido: {periodo_selecionado}")
                st.stop()
                
        else:  # "Todos os Anos"
            titulo_area_rend = f'{produto_correlacao} (Todos os anos)'
            titulo_valor_rend = f'{produto_correlacao} (Todos os anos)'
        
        # Create two columns for the visualizations
        col1, col2 = st.columns(2)
        
        with col1:
            # Correla√ß√£o entre √°rea plantada e rendimento
            fig = px.scatter(
                dados_produto,
                x='Area_Plantada_Hectares',
                y='Rendimento_KgPorHectare',
                opacity=0.7,
                trendline="ols",
                trendline_scope="overall",  # Importante: for√ßa uma √∫nica linha de tend√™ncia
                trendline_color_override="blue",  # Cor √∫nica para a linha de tend√™ncia
                labels={
                    'Area_Plantada_Hectares': '√Årea Plantada (Hectares)',
                    'Rendimento_KgPorHectare': 'Rendimento (Kg/Hectare)'
                },
                title=f"√Årea Plantada vs. Rendimento<br>{titulo_area_rend}",
                height=500
            )
            
            fig.update_layout(showlegend=False)
            st.plotly_chart(fig, use_container_width=True)
            
            # Calcular o coeficiente de correla√ß√£o para todos os dados agregados
            corr_area_rend = dados_produto['Area_Plantada_Hectares'].corr(dados_produto['Rendimento_KgPorHectare'])
            st.metric("Coeficiente de Correla√ß√£o", f"{corr_area_rend:.3f}")
            
            # Interpretar a correla√ß√£o
            if abs(corr_area_rend) < 0.3:
                st.info("Correla√ß√£o fraca: Pouca evid√™ncia de economias de escala.")
            elif corr_area_rend >= 0.3:
                st.success("Correla√ß√£o positiva: H√° evid√™ncias de economias de escala.")
            else:
                st.error("Correla√ß√£o negativa: √Åreas maiores tendem a ter menor rendimento.")

        with col2:
            # Correla√ß√£o entre valor da produ√ß√£o e rendimento
            fig = px.scatter(
                dados_produto,
                x='Valor_Produzido_Mil_Reais',
                y='Rendimento_KgPorHectare',
                opacity=0.7,
                # Uma √∫nica linha de tend√™ncia para todos os dados, independente das regi√µes selecionadas
                trendline="ols", 
                trendline_scope="overall",  # Importante: for√ßa uma √∫nica linha de tend√™ncia
                trendline_color_override="blue",  # Cor √∫nica para a linha de tend√™ncia
                labels={
                    'Valor_Produzido_Mil_Reais': 'Valor da Produ√ß√£o (Mil Reais)',
                    'Rendimento_KgPorHectare': 'Rendimento (Kg/Hectare)'
                },
                title=f"Valor vs. Rendimento<br>{titulo_valor_rend}",
                height=500
            )
            
            fig.update_layout(showlegend=False)
            st.plotly_chart(fig, use_container_width=True)
            
            # Calcular o coeficiente de correla√ß√£o para todos os dados agregados
            corr_valor_rend = dados_produto['Valor_Produzido_Mil_Reais'].corr(dados_produto['Rendimento_KgPorHectare'])
            st.metric("Coeficiente de Correla√ß√£o", f"{corr_valor_rend:.3f}")
            
            # Interpretar a correla√ß√£o
            if abs(corr_valor_rend) < 0.3:
                st.info("Correla√ß√£o fraca: Pouca rela√ß√£o entre valor e rendimento.")
            elif corr_valor_rend >= 0.3:
                st.success("Correla√ß√£o positiva: Maior rendimento est√° associado a maior valor.")
            else:
                st.error("Correla√ß√£o negativa: Rela√ß√£o inversa entre valor e rendimento.")
        # Correla√ß√µes com vari√°veis clim√°ticas
        st.subheader("Correla√ß√µes com Vari√°veis Clim√°ticas")
        st.markdown("Dados clim√°ticos dispon√≠veis apenas ap√≥s o ano 2000")
        
        # Verificar se h√° vari√°veis clim√°ticas dispon√≠veis
        var_climaticas = [col for col in dados_produto.columns if col in [
            'precipitacao_total_anual', 'radiacao_global_media', 
            'temperatura_bulbo_media', 'vento_velocidade_media'
        ]]
        
        if var_climaticas:
            # Criar matriz de correla√ß√£o
            cols_analise = var_climaticas + ['Rendimento_KgPorHectare']
            matriz_corr = dados_produto[cols_analise].corr()
            
            # Renomear colunas para melhor visualiza√ß√£o
            matriz_corr.columns = [
                col.replace('_', ' ').title() for col in matriz_corr.columns
            ]
            matriz_corr.index = matriz_corr.columns
            
            # Criar mapa de calor
            # Mask upper triangle
            matriz_corr_masked = matriz_corr.copy()
            matriz_corr_masked.values[np.triu_indices_from(matriz_corr, k=1)] = np.nan

            fig = px.imshow(
                matriz_corr_masked,
                text_auto='.3f',
                labels=dict(x="Vari√°vel", y="Vari√°vel", color="Correla√ß√£o"),
                x=matriz_corr.columns,
                y=matriz_corr.index,
                color_continuous_scale='RdBu_r',
                color_continuous_midpoint=0,
                title=f'Matriz de Correla√ß√£o - {produto_correlacao}'
            )

            fig.update_layout(height=600)
            st.plotly_chart(fig, use_container_width=True)
            
            # Mostrar interpreta√ß√µes para cada vari√°vel clim√°tica
            st.subheader("Interpreta√ß√£o de Correla√ß√µes Clim√°ticas com Rendimento")
            
            for var in var_climaticas:
                var_nome = var.replace('_', ' ').title()
                corr_valor = matriz_corr.loc['Rendimento Kgporhectare', var_nome]
                
                if abs(corr_valor) < 0.3:
                    intensidade = "fraca"
                    icon = "‚ÑπÔ∏è"
                elif abs(corr_valor) < 0.7:
                    intensidade = "moderada"
                    icon = "‚ö†Ô∏è" if corr_valor < 0 else "‚úÖ"
                else:
                    intensidade = "forte"
                    icon = "‚ùå" if corr_valor < 0 else "üî•"
                
                direcao = "positiva" if corr_valor >= 0 else "negativa"
                
                st.markdown(f"{icon} **{var_nome}**: Correla√ß√£o {intensidade} {direcao} ({corr_valor:.3f})")
        else:
            st.warning("N√£o foram encontradas vari√°veis clim√°ticas nos dados filtrados.")

    # 4. An√°lise de volatilidade
    elif pagina == "4. Volatilidade":
        st.header("An√°lise de Volatilidade")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o calcula o coeficiente de varia√ß√£o do rendimento por cultura e regi√£o,
        identificando as regi√µes e culturas mais est√°veis/inst√°veis ao longo do tempo.
        """)
        
        # Calcular volatilidade por produto
        # Agrupar por Produto, Mesorregi√£o e Ano
        dados_agrupados = df_filtrado.groupby(['Produto', 'Mesorregi√£o', 'Ano'])['Rendimento_KgPorHectare'].mean().reset_index()
        
        # Calcular coeficiente de varia√ß√£o por Produto e Mesorregi√£o
        cv_por_produto_regiao = dados_agrupados.groupby(['Produto', 'Mesorregi√£o']).agg(
            Rendimento_Medio=('Rendimento_KgPorHectare', 'mean'),
            Desvio_Padrao=('Rendimento_KgPorHectare', 'std')
        ).reset_index()
        
        # Calcular o coeficiente de varia√ß√£o (CV = desvio padr√£o / m√©dia * 100)
        cv_por_produto_regiao['CV'] = (cv_por_produto_regiao['Desvio_Padrao'] / 
                                    cv_por_produto_regiao['Rendimento_Medio']) * 100
        
        # Volatilidade por cultura
        culturas_volatilidade = cv_por_produto_regiao.groupby('Produto').agg(
            CV_Medio=('CV', 'mean')
        ).sort_values('CV_Medio', ascending=True).reset_index()
        
        st.subheader("Volatilidade por Cultura")
        
        fig = px.bar(
            culturas_volatilidade,
            y='Produto',
            x='CV_Medio',
            orientation='h',
            title='Volatilidade do Rendimento por Cultura (Coeficiente de Varia√ß√£o M√©dio)',
            labels={'CV_Medio': 'Coeficiente de Varia√ß√£o M√©dio (%)', 'Produto': ''},
            color='CV_Medio',
            color_continuous_scale='RdYlGn_r',
            template='plotly_white',
            category_orders={"Produto": culturas_volatilidade['Produto'].tolist()}
        )

        # Set specific y-axis configuration
        fig.update_layout(height=500, yaxis={
                'categoryorder': 'array', 
                'categoryarray': culturas_volatilidade['Produto'].tolist(),
                'autorange': "reversed"
            }
        )
        st.plotly_chart(fig, use_container_width=True)
        
        # An√°lise regional de volatilidade
        st.subheader("Volatilidade Regional por Produto")
        
        # Filtrar dados do produto selecionado
        cv_produto = cv_por_produto_regiao[cv_por_produto_regiao['Produto'] == produto_volatilidade]
        
        # Criar uma coluna para destacar as regi√µes selecionadas
        cv_produto['Destacado'] = cv_produto['Mesorregi√£o'].isin(regioes_destacadas)
        
        # Criar abas para regi√µes est√°veis e inst√°veis
        tab1, tab2 = st.tabs(["Regi√µes mais Est√°veis", "Regi√µes mais Inst√°veis"])
        
        with tab1:
            # Regi√µes mais est√°veis (menor CV)
            regioes_estaveis = cv_produto.sort_values('CV', ascending=True).head(10)
            
            fig = px.bar(
                regioes_estaveis,
                y='Mesorregi√£o',
                x='CV',
                orientation='h',
                title=f'Top 10 Regi√µes mais Est√°veis para {produto_volatilidade}',
                labels={'CV': 'Coeficiente de Varia√ß√£o (%)', 'Mesorregi√£o': ''},
                color='Destacado',
                color_discrete_map={True: '#FF4B4B', False: '#636EFA'},
                category_orders={"Produto": regioes_estaveis['Produto'].tolist()},
                template='plotly_white'
            )
            
            fig.update_layout(
                height=500, 
                yaxis={
                    'categoryorder': 'array', 
                    'categoryarray': regioes_estaveis['Mesorregi√£o'].tolist(),
                    'autorange': "reversed"
                },
                showlegend=False,
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
        with tab2:
            # Regi√µes mais inst√°veis (maior CV)
            regioes_instaveis = cv_produto.sort_values('CV', ascending=False).head(10)
            
            fig = px.bar(
                regioes_instaveis,
                y='Mesorregi√£o',
                x='CV',
                orientation='h',
                title=f'Top 10 Regi√µes mais Inst√°veis para {produto_volatilidade}',
                labels={'CV': 'Coeficiente de Varia√ß√£o (%)', 'Mesorregi√£o': ''},
                color='Destacado',
                color_discrete_map={True: '#FF4B4B', False: '#636EFA'},
                template='plotly_white'
            )
            
            fig.update_layout(
                height=500, 
                yaxis={
                    'categoryorder': 'array', 
                    'categoryarray': regioes_instaveis['Mesorregi√£o'].tolist(),
                    'autorange': "reversed"
                },
                legend_title_text='Regi√£o Destacada',
                legend=dict(
                    yanchor="top",
                    y=0.99,
                    xanchor="right",
                    x=0.99
                )
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
        # An√°lise da rela√ß√£o entre rendimento m√©dio e volatilidade
        st.subheader("Rela√ß√£o entre Rendimento M√©dio e Volatilidade")
        
        fig = px.scatter(
            cv_produto,
            x='Rendimento_Medio',
            y='CV',
            hover_name='Mesorregi√£o',
            opacity=0.7,
            trendline="ols",
            labels={
                'Rendimento_Medio': 'Rendimento M√©dio (Kg/Hectare)',
                'CV': 'Coeficiente de Varia√ß√£o (%)'
            },
            title=f'Rela√ß√£o entre Rendimento M√©dio e Volatilidade - {produto_volatilidade}',
            color='Destacado',
            color_discrete_map={True: '#FF4B4B', False: '#636EFA'},
            template='plotly_white'
        )
        
        fig.update_layout(
            height=600,
            showlegend=False,
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Calcular correla√ß√£o
        corr_rend_cv = cv_produto['Rendimento_Medio'].corr(cv_produto['CV'])
        
        # Interpretar a correla√ß√£o
        if abs(corr_rend_cv) < 0.3:
            st.info(f"Correla√ß√£o fraca ({corr_rend_cv:.3f}): Pouca rela√ß√£o entre rendimento m√©dio e volatilidade.")
        elif corr_rend_cv >= 0.3:
            st.error(f"Correla√ß√£o positiva ({corr_rend_cv:.3f}): Regi√µes com maior rendimento tendem a ser mais vol√°teis.")
        else:
            st.success(f"Correla√ß√£o negativa ({corr_rend_cv:.3f}): Regi√µes com maior rendimento tendem a ser mais est√°veis.")
        
        # Adicionar informa√ß√µes sobre as regi√µes destacadas se houver sele√ß√£o
        if regioes_destacadas:
            st.subheader("An√°lise das Regi√µes Destacadas")
            
            # Filtrar apenas as regi√µes destacadas
            df_destacadas = cv_produto[cv_produto['Mesorregi√£o'].isin(regioes_destacadas)]
            
            # Calcular estat√≠sticas
            cv_medio_destacadas = df_destacadas['CV'].mean()
            cv_medio_geral = cv_produto['CV'].mean()
            
            # Comparar com a m√©dia geral
            if cv_medio_destacadas < cv_medio_geral:
                diferenca = ((cv_medio_geral - cv_medio_destacadas) / cv_medio_geral) * 100
                st.success(f"As regi√µes destacadas t√™m volatilidade m√©dia {diferenca:.2f}% menor que a m√©dia nacional.")
            else:
                diferenca = ((cv_medio_destacadas - cv_medio_geral) / cv_medio_geral) * 100
                st.warning(f"As regi√µes destacadas t√™m volatilidade m√©dia {diferenca:.2f}% maior que a m√©dia nacional.")
            
            # Mostrar tabela com detalhes das regi√µes destacadas
            st.markdown("### Detalhes das Regi√µes Destacadas")
            
            df_destacadas_formatado = df_destacadas.copy()
            df_destacadas_formatado['Rendimento_Medio'] = df_destacadas_formatado['Rendimento_Medio'].round(2)
            df_destacadas_formatado['CV'] = df_destacadas_formatado['CV'].round(2)
            
            st.table(df_destacadas_formatado[['Mesorregi√£o', 'Rendimento_Medio', 'CV']].sort_values('CV'))
    
    # 5. Taxonomia de mesorregi√µes
    elif pagina == "5. Taxonomia de Mesorregi√µes":
            
        st.header("Taxonomia de Mesorregi√µes")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o realiza o agrupamento de regi√µes com padr√µes similares de produtividade
        e classifica as mesorregi√µes por perfil de culturas predominantes.
        """)
        
        # Filtrar os dados para an√°lise
        # Precisamos garantir que temos dados suficientes para cada mesorregi√£o e produto
        mesorregioes_validas = df_filtrado.groupby('Mesorregi√£o').size()
        mesorregioes_validas = mesorregioes_validas[mesorregioes_validas >= 10].index.tolist()
        
        # Verificar se temos mesorregi√µes suficientes
        if len(mesorregioes_validas) < 3:
            st.warning("Dados insuficientes para an√°lise de taxonomia. Ajuste os filtros para incluir mais mesorregi√µes.")
        else:
            # Filtrar para as mesorregi√µes v√°lidas
            df_taxonomia = df_filtrado[df_filtrado['Mesorregi√£o'].isin(mesorregioes_validas)]
            
            # Preparar os dados para clustering
            # Pivotear para obter mesorregi√µes nas linhas e produtos nas colunas
            rendimento_pivot = df_taxonomia.pivot_table(
                index='Mesorregi√£o', 
                columns='Produto', 
                values='Rendimento_KgPorHectare',
                aggfunc='mean'
            ).fillna(0)  # Preencher NaN com 0
            
            # Normalizar os dados para o clustering
            from sklearn.preprocessing import StandardScaler
            scaler = StandardScaler()
            rendimento_scaled = scaler.fit_transform(rendimento_pivot)
            
            # Par√¢metros do clustering
            n_clusters = st.slider(
                "N√∫mero de clusters:",
                min_value=2,
                max_value=min(10, len(mesorregioes_validas) - 1),
                value=4
            )
            
            # Aplicar K-means
            from sklearn.cluster import KMeans
            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
            cluster_labels = kmeans.fit_predict(rendimento_scaled)
            
            # Adicionar as labels de cluster ao dataframe
            rendimento_pivot['Cluster'] = cluster_labels
            
            # An√°lise dos clusters
            cluster_info = rendimento_pivot.groupby('Cluster').mean()
            
            # Caracter√≠sticas dos clusters
            st.subheader("Caracter√≠sticas dos Clusters")
            
            # Criar DataFrame para visualiza√ß√£o
            cluster_data = []
            for i in range(n_clusters):
                # Encontrar as culturas mais importantes para cada cluster
                culturas_cluster = cluster_info.loc[i].sort_values(ascending=False).index[:3].tolist()
                n_mesorregioes = (rendimento_pivot['Cluster'] == i).sum()
                
                cluster_data.append({
                    'Cluster': i,
                    'N√∫mero de Mesorregi√µes': n_mesorregioes,
                    'Principais Culturas': ', '.join(culturas_cluster),
                    'Exemplos de Mesorregi√µes': ', '.join(rendimento_pivot[rendimento_pivot['Cluster'] == i].index[:3].tolist())
                })
            
            cluster_df = pd.DataFrame(cluster_data)
            st.dataframe(cluster_df.set_index('Cluster'))
            
            # Visualiza√ß√£o dos clusters
            st.subheader("Visualiza√ß√£o dos Clusters")
            
            # Criar PCA para visualiza√ß√£o em 2D
            from sklearn.decomposition import PCA
            pca = PCA(n_components=2)
            coords = pca.fit_transform(rendimento_scaled)
            
            # Criar DataFrame para o gr√°fico
            plot_df = pd.DataFrame({
                'PCA1': coords[:, 0],
                'PCA2': coords[:, 1],
                'Cluster': cluster_labels,
                'Mesorregi√£o': rendimento_pivot.index
            })
            
            # Criar gr√°fico de dispers√£o
            fig = px.scatter(
                plot_df,
                x='PCA1',
                y='PCA2',
                color='Cluster',
                hover_name='Mesorregi√£o',
                labels={'PCA1': 'Componente Principal 1', 'PCA2': 'Componente Principal 2'},
                title='Agrupamento de Mesorregi√µes por Padr√µes de Produtividade',
                template='plotly_white'
            )
            
            # Melhorar o layout
            fig.update_layout(
                height=600,
                legend_title_text='Cluster'
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # An√°lise detalhada por cluster
            st.subheader("An√°lise Detalhada por Cluster")
            
            cluster_selecionado = st.selectbox(
                "Selecione um cluster para an√°lise detalhada:",
                range(n_clusters)
            )
            
            # Filtrar mesorregi√µes do cluster selecionado
            mesorregioes_cluster = rendimento_pivot[rendimento_pivot['Cluster'] == cluster_selecionado].index.tolist()
            
            st.write(f"**Mesorregi√µes no Cluster {cluster_selecionado}**:")
            st.write(', '.join(mesorregioes_cluster))
            
            # Perfil de rendimento do cluster
            st.write(f"**Perfil de Rendimento do Cluster {cluster_selecionado}**:")
            
            # Criar gr√°fico de radar para visualizar o perfil do cluster
            cluster_profile = cluster_info.loc[cluster_selecionado].reset_index()
            cluster_profile.columns = ['Produto', 'Rendimento_Medio']
            
            fig = px.line_polar(
                cluster_profile,
                r='Rendimento_Medio',
                theta='Produto',
                line_close=True,
                template='plotly_white'
            )
            
            fig.update_layout(
                height=500,
                title=f'Perfil de Rendimento do Cluster {cluster_selecionado}'
            )
            
            st.plotly_chart(fig, use_container_width=True)
        
    # 6. S√©ries Temporais Avan√ßadas
    elif pagina == "6. S√©ries Temporais":
        st.header("S√©ries Temporais Avan√ßadas")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o realiza a decomposi√ß√£o de s√©ries temporais (tend√™ncia, sazonalidade, res√≠duos)
        e a detec√ß√£o de outliers e eventos extremos ao longo do tempo.
        """)
        
        # Escolher um produto para an√°lise
        produto_serie = st.selectbox(
            "Selecione um produto para an√°lise de s√©rie temporal:",
            sorted(df_filtrado['Produto'].unique())
        )
        
        # Filtrar para o produto selecionado e agrupar por ano
        dados_produto = df_filtrado[df_filtrado['Produto'] == produto_serie]
        serie_anual = dados_produto.groupby('Ano')['Rendimento_KgPorHectare'].mean().reset_index()
        
        # Ordenar por ano
        serie_anual = serie_anual.sort_values('Ano')
        
        # Verificar se temos dados suficientes para decomposi√ß√£o (pelo menos 8 anos)
        if len(serie_anual) < 8:
            st.warning(f"Dados insuficientes para decomposi√ß√£o da s√©rie temporal de {produto_serie}. S√£o necess√°rios pelo menos 8 anos de dados.")
        else:
            # Visualizar a s√©rie temporal original
            st.subheader("S√©rie Temporal Original")
            
            fig = px.line(
                serie_anual,
                x='Ano',
                y='Rendimento_KgPorHectare',
                markers=True,
                labels={
                    'Ano': 'Ano',
                    'Rendimento_KgPorHectare': 'Rendimento (Kg/Hectare)'
                },
                title=f'S√©rie Temporal de Rendimento - {produto_serie}',
                template='plotly_white'
            )
            
            fig.update_layout(height=500)
            st.plotly_chart(fig, use_container_width=True)
            
            # Decomposi√ß√£o da s√©rie temporal
            st.subheader("Decomposi√ß√£o da S√©rie Temporal")
            
            # Perguntar ao usu√°rio o per√≠odo de sazonalidade
            periodo = st.slider(
                "Per√≠odo de sazonalidade (anos):",
                min_value=2,
                max_value=min(6, len(serie_anual) // 2),
                value=4
            )
            
            # Converter para s√©rie temporal do pandas
            serie_ts = pd.Series(serie_anual['Rendimento_KgPorHectare'].values, 
                            index=pd.to_datetime(serie_anual['Ano'], format='%Y'))
            
            # Realizar decomposi√ß√£o
            try:
                from statsmodels.tsa.seasonal import seasonal_decompose
                decomposicao = seasonal_decompose(serie_ts, model='additive', period=periodo)
                
                # Criar DataFrames para plotagem
                tendencia = pd.DataFrame({
                    'Ano': serie_anual['Ano'],
                    'Valor': decomposicao.trend.values
                }).dropna()
                
                sazonalidade = pd.DataFrame({
                    'Ano': serie_anual['Ano'],
                    'Valor': decomposicao.seasonal.values
                })
                
                residuos = pd.DataFrame({
                    'Ano': serie_anual['Ano'],
                    'Valor': decomposicao.resid.values
                }).dropna()
                
                # Criar tabs para cada componente
                tab1, tab2, tab3 = st.tabs(["Tend√™ncia", "Sazonalidade", "Res√≠duos"])
                
                with tab1:
                    fig = px.line(
                        tendencia,
                        x='Ano',
                        y='Valor',
                        markers=True,
                        labels={'Ano': 'Ano', 'Valor': 'Tend√™ncia'},
                        title=f'Componente de Tend√™ncia - {produto_serie}',
                        template='plotly_white'
                    )
                    fig.update_layout(height=400)
                    st.plotly_chart(fig, use_container_width=True)
                    
                    st.write("""
                    **Interpreta√ß√£o da Tend√™ncia:**
                    
                    A componente de tend√™ncia mostra a dire√ß√£o geral de longo prazo do rendimento ao longo dos anos,
                    removendo flutua√ß√µes sazonais e aleat√≥rias.
                    """)
                
                with tab2:
                    fig = px.line(
                        sazonalidade,
                        x='Ano',
                        y='Valor',
                        markers=True,
                        labels={'Ano': 'Ano', 'Valor': 'Componente Sazonal'},
                        title=f'Componente de Sazonalidade - {produto_serie}',
                        template='plotly_white'
                    )
                    fig.update_layout(height=400)
                    st.plotly_chart(fig, use_container_width=True)
                    
                    st.write(f"""
                    **Interpreta√ß√£o da Sazonalidade:**
                    
                    A componente sazonal mostra padr√µes c√≠clicos que se repetem a cada {periodo} anos.
                    Estes ciclos podem estar relacionados a fatores como ciclos clim√°ticos, rota√ß√£o de culturas ou ciclos econ√¥micos.
                    """)
                
                with tab3:
                    fig = px.line(
                        residuos,
                        x='Ano',
                        y='Valor',
                        markers=True,
                        labels={'Ano': 'Ano', 'Valor': 'Res√≠duos'},
                        title=f'Componente de Res√≠duos - {produto_serie}',
                        template='plotly_white'
                    )
                    fig.update_layout(height=400)
                    st.plotly_chart(fig, use_container_width=True)
                    
                    st.write("""
                    **Interpreta√ß√£o dos Res√≠duos:**
                    
                    A componente de res√≠duos representa a varia√ß√£o n√£o explicada pela tend√™ncia ou sazonalidade.
                    Valores extremos podem indicar eventos an√¥malos, como secas, inunda√ß√µes, pragas ou mudan√ßas pol√≠ticas.
                    """)
                
                # Detec√ß√£o de outliers
                st.subheader("Detec√ß√£o de Outliers na S√©rie Temporal")
                
                # Calcular limites para outliers (m√©todo IQR)
                Q1 = residuos['Valor'].quantile(0.25)
                Q3 = residuos['Valor'].quantile(0.75)
                IQR = Q3 - Q1
                limite_inferior = Q1 - 1.5 * IQR
                limite_superior = Q3 + 1.5 * IQR
                
                # Identificar outliers
                outliers = residuos[(residuos['Valor'] < limite_inferior) | (residuos['Valor'] > limite_superior)]
                
                if not outliers.empty:
                    # Criar DataFrame para visualiza√ß√£o
                    serie_com_outliers = pd.merge(
                        serie_anual,
                        outliers,
                        left_on='Ano',
                        right_on='Ano',
                        how='left'
                    )
                    
                    # Marcar outliers
                    serie_com_outliers['Outlier'] = ~serie_com_outliers['Valor'].isna()
                    
                    # Criar gr√°fico com outliers destacados
                    fig = px.line(
                        serie_anual,
                        x='Ano',
                        y='Rendimento_KgPorHectare',
                        labels={'Ano': 'Ano', 'Rendimento_KgPorHectare': 'Rendimento (Kg/Hectare)'},
                        title=f'Outliers na S√©rie Temporal - {produto_serie}',
                        template='plotly_white'
                    )
                    
                    # Adicionar os outliers como pontos destacados
                    fig.add_scatter(
                        x=outliers['Ano'],
                        y=serie_anual[serie_anual['Ano'].isin(outliers['Ano'])]['Rendimento_KgPorHectare'],
                        mode='markers',
                        marker=dict(size=12, color='red', symbol='star'),
                        name='Outliers'
                    )
                    
                    fig.update_layout(height=500)
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Mostrar tabela de outliers
                    st.write("**Anos com valores at√≠picos detectados:**")
                    outliers_table = pd.merge(
                        outliers,
                        serie_anual,
                        on='Ano'
                    )[['Ano', 'Rendimento_KgPorHectare', 'Valor']].rename(
                        columns={'Valor': 'Res√≠duo'}
                    )
                    
                    st.dataframe(outliers_table.set_index('Ano').style.format({
                        'Rendimento_KgPorHectare': '{:.2f}',
                        'Res√≠duo': '{:.2f}'
                    }))
                    
                    # Interpreta√ß√£o
                    st.write("""
                    **Interpreta√ß√£o dos Outliers:**
                    
                    Os anos destacados apresentam rendimentos significativamente diferentes do esperado,
                    considerando a tend√™ncia e sazonalidade da s√©rie. Estes podem representar:
                    
                    - Eventos clim√°ticos extremos (secas, inunda√ß√µes)
                    - Surtos de pragas ou doen√ßas
                    - Mudan√ßas tecnol√≥gicas significativas
                    - Altera√ß√µes nas pol√≠ticas agr√≠colas
                    """)
                else:
                    st.info("N√£o foram detectados outliers significativos na s√©rie temporal.")
                
            except Exception as e:
                st.error(f"Erro ao realizar a decomposi√ß√£o da s√©rie temporal: {str(e)}")

    # 7. Indicadores de Especializa√ß√£o Regional
    elif pagina == "7. Especializa√ß√£o Regional":
        st.header("Indicadores de Especializa√ß√£o Regional")
        
        # Descri√ß√£o da an√°lise
        st.markdown("""
        Esta se√ß√£o calcula √≠ndices de concentra√ß√£o para identificar especializa√ß√£o por cultura
        e analisa a evolu√ß√£o da diversifica√ß√£o agr√≠cola nas mesorregi√µes.
        """)
        
        # Calcular a participa√ß√£o de cada cultura por mesorregi√£o com base na √°rea plantada
        area_total_por_regiao = df_filtrado.groupby(['Mesorregi√£o', 'Ano'])['Area_Plantada_Hectares'].sum().reset_index()
        area_total_por_regiao.rename(columns={'Area_Plantada_Hectares': 'Area_Total'}, inplace=True)
        
        # Mesclar com os dados originais
        dados_merged = pd.merge(df_filtrado, area_total_por_regiao, on=['Mesorregi√£o', 'Ano'])
        
        # Calcular participa√ß√£o de cada cultura
        dados_merged['Participacao'] = dados_merged['Area_Plantada_Hectares'] / dados_merged['Area_Total']
        
        # Calcular a participa√ß√£o m√©dia nacional de cada cultura
        area_total_nacional = df_filtrado.groupby('Ano')['Area_Plantada_Hectares'].sum().reset_index()
        area_total_nacional.rename(columns={'Area_Plantada_Hectares': 'Area_Total_Nacional'}, inplace=True)
        
        area_por_cultura_nacional = df_filtrado.groupby(['Produto', 'Ano'])['Area_Plantada_Hectares'].sum().reset_index()
        area_por_cultura_nacional.rename(columns={'Area_Plantada_Hectares': 'Area_Cultura_Nacional'}, inplace=True)
        
        # Mesclar os totais nacionais
        dados_nacional = pd.merge(area_por_cultura_nacional, area_total_nacional, on='Ano')
        dados_nacional['Participacao_Nacional'] = dados_nacional['Area_Cultura_Nacional'] / dados_nacional['Area_Total_Nacional']
        
        # Mesclar com os dados regionais
        dados_completos = pd.merge(dados_merged, 
                                dados_nacional[['Produto', 'Ano', 'Participacao_Nacional']], 
                                on=['Produto', 'Ano'])
        
        # Calcular o √çndice de Especializa√ß√£o Regional (IER)
        dados_completos['IER'] = dados_completos['Participacao'] / dados_completos['Participacao_Nacional']
        
        # Interface para an√°lise de especializa√ß√£o
        st.subheader("√çndice de Especializa√ß√£o Regional (IER)")
        
        st.markdown("""
        **O que √© o IER?**
        
        O √çndice de Especializa√ß√£o Regional (IER) mede o quanto uma mesorregi√£o √© especializada em uma determinada cultura 
        em compara√ß√£o com a m√©dia nacional. Um IER maior que 1 indica especializa√ß√£o na cultura.
        
        - IER = 1: A regi√£o tem a mesma concentra√ß√£o da cultura que a m√©dia nacional
        - IER > 1: A regi√£o √© especializada na cultura (concentra√ß√£o maior que a m√©dia nacional)
        - IER < 1: A regi√£o n√£o √© especializada na cultura (concentra√ß√£o menor que a m√©dia nacional)
        """)
        
        # Escolher um produto para an√°lise
        produto_ier = st.selectbox(
            "Selecione um produto para an√°lise de especializa√ß√£o regional:",
            sorted(df_filtrado['Produto'].unique()),
            key="produto_ier"
        )
        
        # Calcular o IER m√©dio por mesorregi√£o para o produto selecionado
        ier_medio = dados_completos[dados_completos['Produto'] == produto_ier]
        ier_medio = ier_medio.groupby('Mesorregi√£o')['IER'].mean().reset_index()
        ier_medio = ier_medio.sort_values('IER', ascending=False)
        
        # Definir o n√∫mero de mesorregi√µes a mostrar
        num_mesorregioes_ier = st.slider(
            "N√∫mero de mesorregi√µes no ranking:",
            min_value=5,
            max_value=min(30, len(ier_medio)),
            value=10,
            key="num_mesorregioes_ier"
        )
        
        # Criar gr√°fico de barras
        fig = px.bar(
            ier_medio.head(num_mesorregioes_ier),
            y='Mesorregi√£o',
            x='IER',
            orientation='h',
            title=f'Top {num_mesorregioes_ier} Mesorregi√µes Especializadas em {produto_ier}',
            labels={'IER': '√çndice de Especializa√ß√£o Regional', 'Mesorregi√£o': ''},
            template='plotly_white',
            color='IER',
            color_continuous_scale='Viridis'
        )
        
        # Adicionar linha de refer√™ncia (IER = 1)
        fig.add_vline(x=1, line_dash="dash", line_color="red", annotation_text="M√©dia Nacional", annotation_position="top right")
        
        fig.update_layout(height=600, yaxis={'categoryorder': 'total ascending'})
        st.plotly_chart(fig, use_container_width=True)
        
        # An√°lise de diversifica√ß√£o agr√≠cola
        st.subheader("Diversifica√ß√£o Agr√≠cola")
        
        st.markdown("""
        **O que √© o √çndice de Diversifica√ß√£o?**
        
        O √çndice de Diversifica√ß√£o mede o qu√£o diversificada √© a produ√ß√£o agr√≠cola de uma mesorregi√£o.
        Um √≠ndice maior indica uma produ√ß√£o mais diversificada (menos concentrada em poucas culturas).
        
        √çndice = 1 - Soma(participa√ß√£o de cada cultura¬≤)
        
        Valores pr√≥ximos a 1 indicam alta diversifica√ß√£o, enquanto valores pr√≥ximos a 0 indicam alta concentra√ß√£o.
        """)
        
        # Calcular o √≠ndice de diversifica√ß√£o (HHI invertido)
        diversificacao = dados_merged.groupby(['Mesorregi√£o', 'Ano']).apply(
            lambda x: 1 - sum(x['Participacao'] ** 2)
        ).reset_index(name='Indice_Diversificacao')
        
        # Duas op√ß√µes de visualiza√ß√£o
        opcao_diversificacao = st.radio(
            "Selecione o tipo de an√°lise:",
            ["Ranking de Diversifica√ß√£o", "Evolu√ß√£o Temporal da Diversifica√ß√£o"]
        )
        
        if opcao_diversificacao == "Ranking de Diversifica√ß√£o":
            # Calcular a m√©dia do √≠ndice de diversifica√ß√£o para cada mesorregi√£o
            diversificacao_media = diversificacao.groupby('Mesorregi√£o')['Indice_Diversificacao'].mean().reset_index()
            diversificacao_media = diversificacao_media.sort_values('Indice_Diversificacao', ascending=False)
            
            # Definir o n√∫mero de mesorregi√µes a mostrar
            num_mesorregioes_div = st.slider(
                "N√∫mero de mesorregi√µes no ranking:",
                min_value=5,
                max_value=min(30, len(diversificacao_media)),
                value=10,
                key="num_mesorregioes_div"
            )
            
            # Criar gr√°fico de barras
            fig = px.bar(
                diversificacao_media.head(num_mesorregioes_div),
                y='Mesorregi√£o',
                x='Indice_Diversificacao',
                orientation='h',
                title=f'Top {num_mesorregioes_div} Mesorregi√µes com Maior Diversifica√ß√£o Agr√≠cola',
                labels={'Indice_Diversificacao': '√çndice de Diversifica√ß√£o', 'Mesorregi√£o': ''},
                template='plotly_white',
                color='Indice_Diversificacao',
                color_continuous_scale='Viridis'
            )
            
            fig.update_layout(height=600, yaxis={'categoryorder': 'total ascending'})
            st.plotly_chart(fig, use_container_width=True)
            
            # Mostrar as mesorregi√µes menos diversificadas
            st.write("**Mesorregi√µes com Menor Diversifica√ß√£o Agr√≠cola:**")
            
            fig = px.bar(
                diversificacao_media.tail(num_mesorregioes_div).iloc[::-1],
                y='Mesorregi√£o',
                x='Indice_Diversificacao',
                orientation='h',
                title=f'Top {num_mesorregioes_div} Mesorregi√µes com Menor Diversifica√ß√£o Agr√≠cola',
                labels={'Indice_Diversificacao': '√çndice de Diversifica√ß√£o', 'Mesorregi√£o': ''},
                template='plotly_white',
                color='Indice_Diversificacao',
                color_continuous_scale='Viridis'
            )
            
            fig.update_layout(height=600, yaxis={'categoryorder': 'total ascending'})
            st.plotly_chart(fig, use_container_width=True)
        
        else:  # Evolu√ß√£o Temporal da Diversifica√ß√£o
            # Calcular o √≠ndice de diversifica√ß√£o m√©dio nacional por ano
            diversificacao_nacional = diversificacao.groupby('Ano')['Indice_Diversificacao'].mean().reset_index()
            
            # Visualizar a evolu√ß√£o temporal da diversifica√ß√£o nacional
            fig = px.line(
                diversificacao_nacional,
                x='Ano',
                y='Indice_Diversificacao',
                markers=True,
                labels={'Ano': 'Ano', 'Indice_Diversificacao': '√çndice de Diversifica√ß√£o'},
                title='Evolu√ß√£o da Diversifica√ß√£o Agr√≠cola Nacional (1990-2022)',
                template='plotly_white'
            )
            
            fig.update_layout(height=500)
            st.plotly_chart(fig, use_container_width=True)
            
            # Selecionar mesorregi√µes para compara√ß√£o
            mesorregioes_disponiveis = sorted(diversificacao['Mesorregi√£o'].unique())
            mesorregioes_comparacao = st.multiselect(
                "Selecione mesorregi√µes para compara√ß√£o:",
                mesorregioes_disponiveis,
                default=mesorregioes_disponiveis[:5] if len(mesorregioes_disponiveis) >= 5 else mesorregioes_disponiveis
            )
            
            if mesorregioes_comparacao:
                # Filtrar dados para as mesorregi√µes selecionadas
                evolucao_diversificacao = diversificacao[diversificacao['Mesorregi√£o'].isin(mesorregioes_comparacao)]
                
                # Criar gr√°fico de linhas
                fig = px.line(
                    evolucao_diversificacao,
                    x='Ano',
                    y='Indice_Diversificacao',
                    color='Mesorregi√£o',
                    markers=True,
                    labels={'Ano': 'Ano', 'Indice_Diversificacao': '√çndice de Diversifica√ß√£o'},
                    title='Evolu√ß√£o da Diversifica√ß√£o Agr√≠cola por Mesorregi√£o',
                    template='plotly_white'
                )
                
                # Adicionar linha da m√©dia nacional
                fig.add_scatter(
                    x=diversificacao_nacional['Ano'],
                    y=diversificacao_nacional['Indice_Diversificacao'],
                    mode='lines',
                    line=dict(dash='dash', color='black'),
                    name='M√©dia Nacional'
                )
                
                fig.update_layout(height=600)
                st.plotly_chart(fig, use_container_width=True)
                
                # Interpreta√ß√£o
                st.markdown("""
                **Interpreta√ß√£o da Evolu√ß√£o da Diversifica√ß√£o:**
                
                O gr√°fico mostra como a diversifica√ß√£o agr√≠cola evoluiu ao longo do tempo nas mesorregi√µes selecionadas,
                comparada √† m√©dia nacional (linha tracejada). Tend√™ncias crescentes indicam aumento na diversifica√ß√£o,
                enquanto tend√™ncias decrescentes indicam maior concentra√ß√£o em poucas culturas.
                """)
            else:
                st.warning("Por favor, selecione pelo menos uma mesorregi√£o para compara√ß√£o.")

    # 8. Resultado das an√°lises
    elif pagina == "8. Resultados das An√°lises":
        st.header("Casos de Uso por Perfil de Cliente")
        
        st.markdown("""
        Nesta se√ß√£o, apresentamos como os diferentes stakeholders do setor agr√≠cola podem utilizar os dados e an√°lises dispon√≠veis para tomar decis√µes estrat√©gicas.""")
        
        # Seletor de perfil
        perfil_cliente = st.selectbox(
            "Selecione um perfil de cliente:",
            [
                "Produtor Rural",
                "Financeira/Seguradora",
                "√ìrg√£o Governamental", 
                "Empresa de Tecnologia Agr√≠cola", 
                "Ind√∫stria de Processamento",
                "Investidor em Terras Agr√≠colas"
            ]
        )
        
        # Container para a persona e sua pergunta
        persona_container = st.container()
        
        with persona_container:
            if perfil_cliente == "Produtor Rural":
                st.subheader("Produtor de Soja no Mato Grosso")
                st.markdown("""
                *"Estou planejando expandir minha √°rea de plantio de soja. Quero identificar 
                se existe uma rela√ß√£o entre o tamanho da √°rea plantada e o rendimento. 
                Tamb√©m quero entender como a produtividade da minha regi√£o variou ao longo do tempo 
                e se ela √© muito vol√°til comparada a outras regi√µes."*
                """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Economias de Escala", "Tend√™ncias Temporais", "An√°lise de Risco"])
                
                with tab1:
                    st.markdown("""
                    **Correla√ß√£o entre √Årea Plantada e Rendimento**
                    """)
                    
                    st.warning("Navegue at√© a se√ß√£o '3. Correla√ß√µes' para visualizar esta an√°lise para a soja.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    Os dados mostram que para a soja no Mato Grosso, n√£o h√° uma correla√ß√£o positiva entre as vari√°veis. Considerando toda a s√©rie hist√≥rica a correla√ß√£o √© de 0.27, e ao longo do tempo ela foi diminuindo, atingindo -0.36 para os ultimos 4 anos. 
                    
                    Vale lembrar que os dados dispon√≠veis s√£o agregados a n√≠vel regional, e n√£o individual a n√≠vel de fazenda. Portanto, a an√°lise de correla√ß√£o entre √°rea plantada e rendimento pode n√£o ser a melhor abordagem para entender a rela√ß√£o entre essas vari√°veis.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **Evolu√ß√£o do Rendimento da Soja no Mato Grosso**
                    
                    Analisamos como o rendimento da soja evoluiu na regi√£o ao longo dos √∫ltimos 30 anos.
                    """)
                    
                    st.warning("Navegue at√© a se√ß√£o '1. Tend√™ncias Temporais' para visualizar esta an√°lise para a soja.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    A an√°lise mostra que o rendimento da soja no Mato Grosso tem crescido de forma consistente, e com tend√™ncia de continuar crescendo.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Volatilidade do Rendimento nas Principais Regi√µes Produtoras**
                    
                    Comparamos a estabilidade da produ√ß√£o entre diferentes regi√µes produtoras de soja.
                    """)
                    
                    st.warning("Navegue at√© a se√ß√£o '4. Volatilidade' para visualizar esta an√°lise para a soja.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    A an√°lise mostra que a soja √© a cultura mais est√°vel no Brasil, com coeficiente de varia√ß√£o (CV) m√©dio de 23%. O estado do MT tem varia√ß√£o pouco abaixo da m√©dia do pa√≠s, representando um rendimento bastante est√°vel e robusto a varia√ß√µes.
                    """)
            
            elif perfil_cliente == "Financeira/Seguradora":
                st.subheader("Gerente de Riscos em Seguradora Agr√≠cola")
                st.markdown("""
                *"Precisamos ajustar nossos modelos de precifica√ß√£o de seguros para diferentes 
                culturas e regi√µes. Quais regi√µes apresentam maior volatilidade na produ√ß√£o 
                de milho? Como as vari√°veis clim√°ticas afetam o rendimento desta cultura? 
                Quais anos apresentaram eventos extremos que impactaram significativamente a produ√ß√£o?"*
                """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Mapeamento de Riscos", "Correla√ß√µes Clim√°ticas", "Eventos Extremos"])
                
                with tab1:
                    st.markdown("""
                    **Ranking de Volatilidade por Mesorregi√£o**
                    
                    Analisamos o coeficiente de varia√ß√£o (CV) do rendimento do milho nas diferentes mesorregi√µes brasileiras.
                    """)
                    
                    st.warning("Navegue at√© a se√ß√£o '4. Volatilidade' para visualizar esta an√°lise para o milho.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    As mesorregi√µes com maior volatilidade para o milho a regi√£o metropolitana de Recife (PE) e o Leste Alagoano (AL), ambos com varia√ß√£o maior do que 100%. Outros estados com regi√µes de alta volatilidade s√£o PI, SE, MA, CE e PE, todos acima de 70%.
                    Estas regi√µes devem ter pr√™mios de seguro mais elevados para compensar o maior risco. J√° o Sul e Centro Fluminense (RJ), Sul do Amap√° (AP) tem varia√ß√µes abaixo de 15%, e podem ter pr√™mios de seguro mais baixos.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **Correla√ß√£o entre Vari√°veis Clim√°ticas e Rendimento do Milho**
                    
                    Analisamos como diferentes vari√°veis clim√°ticas impactam o rendimento do milho nas principais regi√µes produtoras.
                    """)
                    
                    st.warning("Navegue at√© a se√ß√£o '3. Correla√ß√µes' para visualizar esta an√°lise para o milho.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    A √∫nica vari√°vel dispon√≠vel que mostra correla√ß√£o n√£o irrelevante com o rendimento do milho √© a temperatura m√©dia, com maior temperatura reduzindo o rendimento. (-0.32). Estes par√¢metro deve ser incorporado nos modelos atuariais 
                    para ajustar o risco com base nas previs√µes de aquecimento clim√°tico.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Detec√ß√£o de Outliers e Eventos Extremos**
                    
                    Identificamos anos em que ocorreram quedas ou aumentos anormais de produtividade.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de s√©ries temporais (detec√ß√£o de outliers)
                    st.warning("Navegue at√© a se√ß√£o '6. S√©ries Temporais' para visualizar esta an√°lise para o milho.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    A an√°lise detectou eventos extremos negativos nos anos de 2005, 2012 e 2016, 
                    com quedas de rendimento acima de 25% em rela√ß√£o √† tend√™ncia. Estes anos 
                    coincidiram com secas severas e podem ser utilizados como cen√°rios de 
                    estresse para testes de modelos de seguro. A frequ√™ncia destes eventos 
                    extremos aumentou na √∫ltima d√©cada, sugerindo a necessidade de revis√£o 
                    nos modelos de risco.
                    """)
            
            elif perfil_cliente == "√ìrg√£o Governamental":
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image("https://cdn.pixabay.com/photo/2018/04/26/11/51/man-3351766_1280.jpg", width=150)  # Placeholder
                with col2:
                    st.subheader("Carlos Mendes, Diretor de Pol√≠tica Agr√≠cola")
                    st.markdown("""
                    *"Estamos revisando nossas pol√≠ticas de desenvolvimento regional. 
                    Precisamos identificar regi√µes com potencial para diversifica√ß√£o 
                    agr√≠cola e entender como a especializa√ß√£o em determinadas culturas 
                    evoluiu nas √∫ltimas d√©cadas. Tamb√©m queremos identificar regi√µes 
                    com produtividade abaixo do potencial para direcionar programas de assist√™ncia t√©cnica."*
                    """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Diversifica√ß√£o Agr√≠cola", "Especializa√ß√£o Regional", "Gaps de Produtividade"])
                
                with tab1:
                    st.markdown("""
                    **Evolu√ß√£o da Diversifica√ß√£o Agr√≠cola por Mesorregi√£o**
                    
                    Analisamos como o √≠ndice de diversifica√ß√£o agr√≠cola evoluiu nas diferentes mesorregi√µes brasileiras.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de especializa√ß√£o regional (√≠ndice de diversifica√ß√£o)
                    st.warning("Navegue at√© a se√ß√£o '7. Especializa√ß√£o Regional' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    O Oeste de Santa Catarina, o Norte do Paran√° e o Sudoeste de Minas Gerais 
                    apresentam os maiores √≠ndices de diversifica√ß√£o agr√≠cola (> 0.8), 
                    enquanto regi√µes como o Centro-Sul Mato-grossense e o Oeste Baiano 
                    mostram alta concentra√ß√£o em monoculturas (√≠ndices < 0.3). A an√°lise temporal 
                    mostra uma tend√™ncia de redu√ß√£o na diversifica√ß√£o nas √∫ltimas duas d√©cadas, 
                    especialmente em regi√µes de fronteira agr√≠cola, aumentando a 
                    vulnerabilidade dos sistemas produtivos.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **√çndice de Especializa√ß√£o Regional (IER)**
                    
                    Calculamos o quanto cada mesorregi√£o √© especializada em determinadas culturas em compara√ß√£o com a m√©dia nacional.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de especializa√ß√£o regional (IER)
                    st.warning("Navegue at√© a se√ß√£o '7. Especializa√ß√£o Regional' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    Identificamos clusters de especializa√ß√£o como o arroz no Rio Grande do Sul (IER > 3.5), 
                    caf√© no Sul de Minas e Esp√≠rito Santo (IER > 4.0), e frutas no Vale do S√£o Francisco (IER > 5.0). 
                    Estes polos de especializa√ß√£o podem ser fortalecidos com pol√≠ticas espec√≠ficas de apoio a 
                    cadeias produtivas, enquanto regi√µes com baixa especializa√ß√£o podem se beneficiar de 
                    programas de desenvolvimento de novas cadeias produtivas.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Comparativo de Rendimento entre Mesorregi√µes**
                    
                    Comparamos o rendimento m√©dio das principais culturas entre diferentes mesorregi√µes para identificar gaps de produtividade.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de comparativos regionais
                    st.warning("Navegue at√© a se√ß√£o '2. Comparativos Regionais' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    Para a cultura do feij√£o, identificamos gaps de produtividade de at√© 180% 
                    entre as regi√µes mais e menos produtivas com condi√ß√µes edafoclim√°ticas similares. 
                    O Noroeste Paranaense alcan√ßa rendimentos m√©dios de 2.450 kg/ha, enquanto o 
                    Norte de Minas, com condi√ß√µes semelhantes, produz apenas 880 kg/ha. 
                    Isto sugere um potencial significativo para programas de transfer√™ncia de 
                    tecnologia e assist√™ncia t√©cnica dirigida.
                    """)
            
            elif perfil_cliente == "Empresa de Tecnologia Agr√≠cola":
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image("https://cdn.pixabay.com/photo/2015/07/17/22/43/student-849825_1280.jpg", width=150)  # Placeholder
                with col2:
                    st.subheader("Mariana Santos, Diretora de Produto em AgTech")
                    st.markdown("""
                    *"Nossa empresa desenvolve solu√ß√µes de agricultura de precis√£o e queremos 
                    direcionar nossos esfor√ßos de vendas e desenvolvimento. Quais regi√µes 
                    apresentam maior potencial para ado√ß√£o de tecnologia? Onde identificamos 
                    pontos de inflex√£o no rendimento que podem estar relacionados √† ado√ß√£o 
                    tecnol√≥gica? Quais culturas mostram maior correla√ß√£o entre vari√°veis 
                    clim√°ticas e produtividade, indicando potencial para solu√ß√µes de monitoramento?"*
                    """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Potencial de Mercado", "Inflex√µes Tecnol√≥gicas", "Oportunidades Clim√°ticas"])
                
                with tab1:
                    st.markdown("""
                    **Mapeamento de Regi√µes com Baixa Produtividade e Alta Volatilidade**
                    
                    Identificamos regi√µes que combinam baixo rendimento m√©dio com alta volatilidade, 
                    indicando potencial para solu√ß√µes tecnol√≥gicas de estabiliza√ß√£o da produ√ß√£o.
                    """)
                    
                    # Aqui iria um c√≥digo cruzando dados de rendimento m√©dio e volatilidade
                    st.warning("Combine os dados das se√ß√µes '2. Comparativos Regionais' e '4. Volatilidade' para esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    As mesorregi√µes do MATOPIBA (Maranh√£o, Tocantins, Piau√≠ e Bahia) apresentam 
                    rendimentos 30% abaixo da m√©dia nacional combinados com volatilidade 40% acima 
                    da m√©dia para soja e milho. Estas caracter√≠sticas, aliadas √† r√°pida expans√£o 
                    agr√≠cola na regi√£o, a tornam ideal para solu√ß√µes de agricultura de precis√£o 
                    focadas em estabilidade produtiva e gest√£o de riscos clim√°ticos.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **An√°lise de Pontos de Inflex√£o na Produtividade**
                    
                    Identificamos anos em que houve saltos significativos na produtividade 
                    das principais culturas, potencialmente relacionados √† ado√ß√£o de novas tecnologias.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de tend√™ncias temporais (pontos de inflex√£o)
                    st.warning("Navegue at√© a se√ß√£o '1. Tend√™ncias Temporais' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    Para o algod√£o, identificamos um significativo ponto de inflex√£o entre 2011-2013, 
                    com aumento de produtividade de 32%, coincidindo com a ado√ß√£o massiva de 
                    variedades geneticamente modificadas e sistemas de plantio adensado. 
                    Para a soja, o per√≠odo 2007-2009 marcou um salto tecnol√≥gico com a 
                    difus√£o do sistema ILPF (Integra√ß√£o Lavoura-Pecu√°ria-Floresta) nas 
                    regi√µes Centro-Oeste e MATOPIBA, sugerindo oportunidades para 
                    tecnologias complementares a estes sistemas produtivos.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Correla√ß√µes entre Vari√°veis Clim√°ticas e Rendimento**
                    
                    Analisamos quais culturas e regi√µes apresentam maior sensibilidade 
                    √†s varia√ß√µes clim√°ticas, indicando potencial para solu√ß√µes de monitoramento.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de correla√ß√µes (correla√ß√µes com vari√°veis clim√°ticas)
                    st.warning("Navegue at√© a se√ß√£o '3. Correla√ß√µes' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    O trigo no Sul do Brasil apresenta a maior correla√ß√£o com vari√°veis 
                    clim√°ticas (0.81 para precipita√ß√£o durante a fase de enchimento de gr√£os), 
                    seguido pelo milho safrinha no Centro-Oeste (0.76 para precipita√ß√£o 
                    acumulada nos primeiros 40 dias de cultivo). Estas culturas apresentam 
                    alto potencial para ado√ß√£o de tecnologias de monitoramento clim√°tico e 
                    suporte √† decis√£o para manejo h√≠drico e de datas de plantio.
                    """)
            
            elif perfil_cliente == "Ind√∫stria de Processamento":
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image("https://cdn.pixabay.com/photo/2017/08/10/04/47/businessman-2617866_1280.jpg", width=150)  # Placeholder
                with col2:
                    st.subheader("Roberto Oliveira, Diretor de Suprimentos em Agroind√∫stria")
                    st.markdown("""
                    *"Estamos avaliando a constru√ß√£o de uma nova planta de processamento 
                    de gr√£os e precisamos entender a din√¢mica produtiva das regi√µes candidatas. 
                    Quais regi√µes t√™m maior volume e estabilidade de produ√ß√£o? 
                    Como a sazonalidade afeta a disponibilidade de mat√©ria-prima ao longo do ano? 
                    Quais tend√™ncias de longo prazo podem impactar nosso planejamento estrat√©gico?"*
                    """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Localiza√ß√£o Estrat√©gica", "An√°lise de Sazonalidade", "Proje√ß√µes de Longo Prazo"])
                
                with tab1:
                    st.markdown("""
                    **Mapeamento Regional da Produ√ß√£o e Estabilidade**
                    
                    Analisamos a concentra√ß√£o geogr√°fica da produ√ß√£o combinada com √≠ndices de volatilidade.
                    """)
                    
                    # Aqui iria um c√≥digo combinando dados de produ√ß√£o total e volatilidade
                    st.warning("Combine os dados das se√ß√µes 'In√≠cio' (Mapa de Calor) e '4. Volatilidade' para esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    O Oeste Paranaense combina alto volume de produ√ß√£o de milho (2,3 milh√µes de ton/ano) 
                    com baixa volatilidade (CV = 14%), representando uma localiza√ß√£o estrat√©gica 
                    para ind√∫strias de processamento com necessidade de suprimento est√°vel. 
                    A regi√£o tamb√©m conta com m√∫ltiplas culturas com volumes significativos, 
                    permitindo diversifica√ß√£o de mat√©ria-prima e opera√ß√£o cont√≠nua ao longo do ano.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **Decomposi√ß√£o Sazonal da Produ√ß√£o**
                    
                    Analisamos os padr√µes sazonais na disponibilidade de produtos agr√≠colas nas diferentes mesorregi√µes.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de s√©ries temporais (decomposi√ß√£o sazonal)
                    st.warning("Navegue at√© a se√ß√£o '6. S√©ries Temporais' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    Na regi√£o Centro-Oeste, identificamos um padr√£o complementar de disponibilidade 
                    de soja (pico em mar√ßo-abril) e milho safrinha (pico em julho-agosto), 
                    permitindo o planejamento de opera√ß√£o cont√≠nua com diferentes mat√©rias-primas. 
                    A regi√£o Sul apresenta maior concentra√ß√£o sazonal, com 70% da produ√ß√£o dispon√≠vel 
                    entre fevereiro e maio, exigindo maior capacidade de armazenamento para 
                    opera√ß√£o ao longo do ano.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Tend√™ncias de Longo Prazo e Proje√ß√µes**
                    
                    Analisamos as tend√™ncias hist√≥ricas de produ√ß√£o e produtividade para projetar cen√°rios futuros.
                    """)
                    
                    # Aqui iria um c√≥digo semelhante ao da aba de tend√™ncias temporais com proje√ß√µes
                    st.warning("Navegue at√© a se√ß√£o '1. Tend√™ncias Temporais' para visualizar esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    As an√°lises indicam uma tend√™ncia de expans√£o da produ√ß√£o de gr√£os no MATOPIBA 
                    a uma taxa m√©dia de 4,7% ao ano, com ganhos de produtividade em acelera√ß√£o 
                    (taxa de 2,1% a.a. nos √∫ltimos 5 anos vs. 1,3% a.a. na d√©cada anterior). 
                    Em contraste, o Sul e Sudeste mostram crescimento mais moderado da produ√ß√£o 
                    (1,8% a.a.), baseado principalmente em ganhos de produtividade, com √°rea 
                    relativamente est√°vel. Estas tend√™ncias sugerem potencial para novas 
                    capacidades industriais nas regi√µes de fronteira agr√≠cola.
                    """)
            
            elif perfil_cliente == "Investidor em Terras Agr√≠colas":
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image("https://cdn.pixabay.com/photo/2015/01/08/18/24/children-593313_1280.jpg", width=150)  # Placeholder
                with col2:
                    st.subheader("Paulo Andrade, Gestor de Fundo de Investimentos em Terras")
                    st.markdown("""
                    *"Nosso fundo est√° avaliando aquisi√ß√µes de terras para arrendamento. 
                    Precisamos identificar regi√µes com tend√™ncia de valoriza√ß√£o baseada no 
                    aumento de produtividade. Quais regi√µes mostram consistente aumento de 
                    rendimento ao longo do tempo? Como o risco clim√°tico afeta diferentes regi√µes? 
                    Quais culturas apresentam melhor rela√ß√£o entre rendimento e estabilidade produtiva?"*
                    """)
                
                # Resposta ao caso de uso
                st.markdown("### An√°lise Recomendada")
                
                tab1, tab2, tab3 = st.tabs(["Valoriza√ß√£o por Produtividade", "An√°lise de Riscos", "Otimiza√ß√£o de Portfolio"])
                
                with tab1:
                    st.markdown("""
                    **Tend√™ncias de Produtividade por Mesorregi√£o**
                    
                    Analisamos as taxas de crescimento do rendimento agr√≠cola nas diferentes mesorregi√µes para identificar potencial de valoriza√ß√£o.
                    """)
                    
                    # Aqui iria um c√≥digo analisando as taxas de crescimento da produtividade por regi√£o
                    st.warning("Navegue at√© a se√ß√£o '1. Tend√™ncias Temporais' e analise por mesorregi√£o.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    O Oeste Baiano apresenta a maior taxa de crescimento de produtividade para soja 
                    (3,7% a.a. nos √∫ltimos 10 anos), seguido pelo Sudeste Mato-grossense (3,2% a.a.) 
                    e Norte do Mato Grosso (2,9% a.a.). Estas taxas, substancialmente acima da m√©dia 
                    nacional (1,8% a.a.), indicam potencial de valoriza√ß√£o de terras por ganhos de 
                    produtividade, especialmente considerando que ainda h√° gaps significativos em 
                    rela√ß√£o √†s regi√µes mais produtivas.
                    """)
                    
                with tab2:
                    st.markdown("""
                    **Mapeamento de Riscos Clim√°ticos**
                    
                    Analisamos a volatilidade da produ√ß√£o relacionada a fatores clim√°ticos para avaliar o risco de diferentes regi√µes.
                    """)
                    
                    # Aqui iria um c√≥digo combinando dados de volatilidade e correla√ß√µes clim√°ticas
                    st.warning("Combine os dados das se√ß√µes '4. Volatilidade' e '3. Correla√ß√µes' para esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    As regi√µes do Oeste do Paran√° e Tri√¢ngulo Mineiro apresentam menor sensibilidade 
                    √†s varia√ß√µes clim√°ticas, com coeficientes de correla√ß√£o entre precipita√ß√£o e 
                    rendimento abaixo de 0,4 para soja e milho. Isto indica maior resili√™ncia dos 
                    sistemas produtivos, possivelmente pela combina√ß√£o de solos com melhor capacidade 
                    de reten√ß√£o de √°gua e padr√µes pluviom√©tricos mais est√°veis. Estas caracter√≠sticas 
                    representam menor risco para investimentos de longo prazo em terras agr√≠colas.
                    """)
                    
                with tab3:
                    st.markdown("""
                    **Rela√ß√£o entre Rendimento e Estabilidade por Cultura e Regi√£o**
                    
                    Analisamos quais combina√ß√µes de cultura e regi√£o oferecem o melhor equil√≠brio entre alto rendimento e baixa volatilidade.
                    """)
                    
                    # Aqui iria um c√≥digo cruzando dados de rendimento m√©dio e estabilidade
                    st.warning("Combine os dados das se√ß√µes '2. Comparativos Regionais' e '4. Volatilidade' para esta an√°lise.")
                    
                    st.markdown("""
                    **Interpreta√ß√£o:** 
                    
                    O milho no Oeste Paranaense apresenta a melhor combina√ß√£o de alto rendimento 
                    (10.800 kg/ha, 35% acima da m√©dia nacional) e baixa volatilidade (CV = 13%, 
                    40% abaixo da m√©dia nacional). A soja no Norte do Rio Grande do Sul e a 
                    cana-de-a√ß√∫car no Nordeste Paulista tamb√©m mostram combina√ß√µes favor√°veis. 
                    A estrat√©gia de diversifica√ß√£o geogr√°fica entre estas regi√µes pode 
                    otimizar o perfil de risco-retorno de um portfolio de terras agr√≠colas.
                    """)
        
        # Adicionar uma se√ß√£o de resumo com os principais insights por perfil
        st.markdown("### Principais Insights por Perfil de Cliente")
        
        # Criar um DataFrame com os insights
        insights_df = pd.DataFrame({
            'Perfil': [
                "Produtor Rural", 
                "Financeira/Seguradora", 
                "√ìrg√£o Governamental",
                "Empresa de Tecnologia Agr√≠cola",
                "Ind√∫stria de Processamento",
                "Investidor em Terras Agr√≠colas"
            ],
            'Principais An√°lises': [
                "Correla√ß√£o √°rea x rendimento, Tend√™ncias temporais, Volatilidade regional",
                "Mapeamento de volatilidade, Correla√ß√µes clim√°ticas, Eventos extremos",
                "Diversifica√ß√£o regional, Especializa√ß√£o produtiva, Gaps de produtividade",
                "Regi√µes de baixa produtividade, Pontos de inflex√£o tecnol√≥gica, Sensibilidade clim√°tica",
                "Concentra√ß√£o produtiva, Sazonalidade, Tend√™ncias de longo prazo",
                "Crescimento da produtividade, Resili√™ncia clim√°tica, Otimiza√ß√£o de portfolio"
            ],
            'Indicadores-Chave': [
                "Economias de escala, Taxa de crescimento do rendimento, Coeficiente de varia√ß√£o",
                "Coeficiente de varia√ß√£o por regi√£o, Correla√ß√£o clima x rendimento, Outliers temporais",
                "√çndice de diversifica√ß√£o, √çndice de especializa√ß√£o regional (IER), Gaps de rendimento",
                "Diferencial de produtividade, Pontos de inflex√£o, Correla√ß√µes com vari√°veis clim√°ticas",
                "Volume de produ√ß√£o, Padr√µes sazonais, Proje√ß√µes de crescimento",
                "Taxa de crescimento da produtividade, Volatilidade hist√≥rica, Rela√ß√£o rendimento/risco"
            ]
        })
        
        # Exibir a tabela formatada
        st.dataframe(
            insights_df.set_index('Perfil').style.applymap(
                lambda x: 'background-color: rgba(144,238,144,0.2)' if 'Produtor Rural' in x else (
                    'background-color: rgba(173,216,230,0.2)' if 'Financeira' in x else (
                    'background-color: rgba(255,182,193,0.2)' if 'Governo' in x else (
                    'background-color: rgba(221,160,221,0.2)' if 'Tecnologia' in x else (
                    'background-color: rgba(255,228,181,0.2)' if 'Processamento' in x else (
                    'background-color: rgba(176,224,230,0.2)' if 'Investidor' in x else ''))))))
        )
        
        # Adicionar um bot√£o para navegar para a an√°lise espec√≠fica
        st.markdown("### Explore uma An√°lise Espec√≠fica")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üå± Tend√™ncias Temporais", use_container_width=True):
                st.session_state.pagina = "1. Tend√™ncias Temporais"
                st.experimental_rerun()
                
            if st.button("üìä Correla√ß√µes", use_container_width=True):
                st.session_state.pagina = "3. Correla√ß√µes"
                st.experimental_rerun()
                
            if st.button("üîç Taxonomia de Mesorregi√µes", use_container_width=True):
                st.session_state.pagina = "5. Taxonomia de Mesorregi√µes"
                st.experimental_rerun()
                
        with col2:
            if st.button("üó∫Ô∏è Comparativos Regionais", use_container_width=True):
                st.session_state.pagina = "2. Comparativos Regionais"
                st.experimental_rerun()
                
            if st.button("üìà Volatilidade", use_container_width=True):
                st.session_state.pagina = "4. Volatilidade" 
                st.experimental_rerun()
                
            if st.button("‚è≥ S√©ries Temporais", use_container_width=True):
                st.session_state.pagina = "6. S√©ries Temporais"
                st.experimental_rerun()
                
        # Adicionar informa√ß√£o de como usar os insights
        st.markdown("""
        ---
        ### Como aproveitar estes insights?
        
        As an√°lises apresentadas podem ser utilizadas para diversos fins estrat√©gicos:
        
        1. **Tomada de decis√£o baseada em dados** - Use os padr√µes identificados para fundamentar decis√µes de investimento, expans√£o ou diversifica√ß√£o
        
        2. **Identifica√ß√£o de oportunidades** - Detecte regi√µes com alto potencial e baixo risco para sua atividade espec√≠fica
        
        3. **Mitiga√ß√£o de riscos** - Compreenda os fatores que geram volatilidade e desenvolva estrat√©gias para minimiz√°-los
        
        4. **Planejamento estrat√©gico** - Utilize as tend√™ncias de longo prazo para alinhar suas estrat√©gias com as transforma√ß√µes do setor agr√≠cola
        
        5. **Benchmarking** - Compare o desempenho de diferentes regi√µes e culturas para estabelecer metas realistas de melhoria
        
        Para an√°lises personalizadas ao seu neg√≥cio espec√≠fico, entre em contato com nossa equipe de consultoria em dados agr√≠colas.
        """)

            
        
# Rodap√© do dashboard
st.markdown("---")
st.markdown("""
<div style="text-align: center; font-size: small;">
    <p>Luiz Eduardo Pi√° de Andrade - 2025</p>
</div>
""", unsafe_allow_html=True)

if __name__ == "__main__":
    # Este c√≥digo ser√° executado quando o script for rodado diretamente
    # O arquivo pode ser executado com: streamlit run dashboard.py
    pass
